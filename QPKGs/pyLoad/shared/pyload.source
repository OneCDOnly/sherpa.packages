#!/usr/bin/env bash
#* <?dont_edit?>
#
#* <?filename?>
#
#* <?copyright?>
#
#* <?project?>
#
#* <?tested?>
#
#* <?license?>

readonly r_user_args_raw=$*
readonly r_qpkg_name=pyLoad
readonly r_service_script_version='<?build_date?>'

InitService()
	{

	# This is a type 6 service-script.

	# NOTE: default session values are set in service function library: uncomment to update, or copy to change.

	# >>> Paths <<<

		# pip_cache_path=undefined
		pip_cache_path=$r_qpkg_path/pip-cache

		# qpkg_repo_path=undefined

		# qpkg_wheels_path=undefined
		qpkg_wheels_path=$r_qpkg_path/qpkg-wheels

		# venv_path=undefined
		venv_path=$r_qpkg_path/venv

	# >>> Filenames <<<

		# qpkg_ini_file=config.ini
		qpkg_ini_file=pyload.cfg

	# >>> Pathfilenames <<<

		# app_version_pathfile=undefined

		# daemon_check_pathfile=undefined							# If set, look for this process pathfilename instead of $daemon_exec_pathfile.

		# daemon_exec_pathfile=undefined							# The pathfilename of the main daemon. If $daemon_script_pathfile is set, then this will be the interpreter to launch.
		daemon_exec_pathfile=$venv_path/bin/python3

		# daemon_pid_pathfile=/var/run/$r_qpkg_name.pid

		# daemon_script_pathfile=undefined							# When an interpreter is to be used, interpret this script.
		daemon_script_pathfile=$venv_path/bin/pyload

		# launcher_pathfile=undefined								# On-demand executables only.

		# qpkg_backup_pathfile=$r_backup_path/$r_qpkg_name.config.tar.gz

		# qpkg_ini_pathfile=$r_qpkg_config_path/$qpkg_ini_file
		qpkg_ini_pathfile=$r_qpkg_config_path/settings/$qpkg_ini_file

		# qpkg_ini_default_pathfile=$qpkg_ini_pathfile.def
		qpkg_ini_default_pathfile=$qpkg_ini_pathfile.def

		# userlink_pathfile=undefined								# On-demand executables only.

		# venv_pip_pathfile=undefined
		venv_pip_pathfile=$venv_path/bin/pip

		# venv_python_pathfile=undefined
		venv_python_pathfile=$venv_path/bin/python3

	# >>> Switches <<<

		# allow_access_to_sys_packages=true

		# can_restart_to_update=false								# If 'true', application can be updated by restarting service-script.
		can_restart_to_update=true

		# daemon_pidfile_is_managed_by_app=false

		# install_pip_deps=false

		# recheck_daemon_pid_after_launch=false						# If 'true', application PID is reconfirmed shortly after initial launch. Some applications launch with one PID, then switch to another.

		# recheck_daemon_pid_after_kill=false						# If 'true', application PID is reconfirmed shortly after kill confirmed. Some applications kill their main PID, then switch to another during shutdown.

		# resolve_remote_url=false									# If 'true', URL must be retrieved from remote first, then parsed to get final URL.

		# run_daemon_in_screen_session=false

		# silence_pypi_errors=true									# If 'true', PyPI package processing errors won't be shown in system log.

	# >>> Values <<<

		# daemon_port=0

		# interpreter=undefined
		interpreter=/opt/bin/python3

		# nice_daemon_to=0											# If non-zero, daemon proc is niced to this value on-launch.

		# orig_daemon_service_script=undefined						# Specific to Entware binaries only.

		# remote_arch=undefined

		# source_arch=undefined

		# source_git_branch=undefined

		# source_git_branch_depth=undefined							# 'shallow' (depth 1) or 'single-branch' ... 'shallow' implies 'single-branch'.

		# ui_listening_address=undefined

		# ui_port=0

		# ui_port_secure=0

		# wait_pid_kill_seconds=10									# This value is adaptive (increases with system load average).

		# wait_pid_start_seconds=10									# This value is adaptive (increases with system load average).

		# watch_pid_kill_seconds=120								# This value is adaptive (increases with system load average).

		# watch_pid_start_seconds=120								# This value is adaptive (increases with system load average).

		# watch_pidfile_start_seconds=60							# This value is adaptive (increases with system load average).

		# watch_port_check_seconds=120								# This value is adaptive (increases with system load average).

	# >>> URLs <<<

		# remote_url=undefined

		# source_git_url=undefined

	# >>> CMDs <<<

		# get_app_version_cmd=undefined

		# get_daemon_port_cmd=undefined

		# get_ui_listening_address_cmd=undefined
		get_ui_listening_address_cmd="GetPyloadConfig $qpkg_ini_pathfile webui host"

		# get_ui_port_cmd=undefined
		get_ui_port_cmd="GetPyloadConfig $qpkg_ini_pathfile webui port"

		# get_ui_port_secure_cmd=undefined
		get_ui_port_secure_cmd="GetPyloadConfig $qpkg_ini_pathfile webui port"

		# get_ui_port_secure_enabled_test_cmd=undefined
		get_ui_port_secure_enabled_test_cmd="[[ $(GetPyloadConfig "$qpkg_ini_pathfile" webui use_ssl) = True ]]"

		# daemon_launch_cmd=undefined
		daemon_launch_cmd="export TEMP=$r_qpkg_temp_path; $daemon_exec_pathfile $daemon_script_pathfile --daemon --userdir $r_qpkg_path/config"

	}

GetPyloadConfig()
	{

	# Inputs: (local)
	#   $1 = pathfilename to read from
	#   $2 = section name
	#   $3 = variable name to return value for

	# Outputs: (local)
	#   $? = 0 : variable found
	#   $? = 1 : file/section/variable not found
	#   stdout = variable value

	local source_pathfile=${1:?no pathfilename supplied}
	local target_section_name=${2:?no section supplied}
	local target_var_name=${3:?no variable supplied}

	if [[ ! -e $source_pathfile ]]; then
		echo false
		return
	fi

	local blank=''
	local end_line_num='$'
	local -i line_num=0
	local raw_var_type=''
	local raw_var_description=''
	local result_line=''
	local section_description=''
	local section_line=''
	local section_name=''
	local section_raw=''
	local -i start_line_num=0
	local target_section=''
	local value=''
	local value_raw=''
	local var_found=false
	local var_name=''
	local var_type=''

	while read -r result_line; do
		IFS=':' read -r line_num section_raw <<< "$result_line"
		IFS=' ' read -r section_name blank section_description <<< "$section_raw"

		if [[ $section_name = "$target_section_name" ]]; then
			[[ $start_line_num -eq 0 ]] && start_line_num=$((line_num+1))
		else
			if [[ $start_line_num -ne 0 ]]; then
				end_line_num=$((line_num-2))
				break
			fi
		fi
	done <<< "$(/bin/grep '.*:$' -n "$source_pathfile")"

	if [[ $start_line_num -eq 0 ]]; then
		echo 'section match not found'
		return 1
	fi

	target_section=$(/bin/sed -n "${start_line_num},${end_line_num}p" "$source_pathfile")

	while read -r section_line; do
		IFS=':' read -r raw_var_type raw_var_description <<< "$section_line"
		read -r var_type var_name <<< "$raw_var_type"

		[[ $var_name != "$target_var_name" ]] && continue

		var_found=true
		IFS='"' read -r blank var_description value_raw <<< "$raw_var_description"
		IFS='=' read -r blank value <<< "$value_raw"
		value=${value% }; value=${value# }
		break
	done <<< "$target_section"

	if [[ $var_found = false ]]; then
		echo 'variable match not found'
		return 1
	fi

	echo "$value"

	}

library_path=$(/usr/bin/readlink "$0" 2>/dev/null)
[[ -z $library_path ]] && library_path=$0
readonly r_service_library_pathfile=$(/usr/bin/dirname "$library_path")/service.lib

if [[ -e $r_service_library_pathfile ]]; then
	. $r_service_library_pathfile
else
	printf '\033[1;31m%s\033[0m: %s\n' 'derp' "QPKG service function library not found, can't continue."
	exit 1
fi

ProcessArgs
