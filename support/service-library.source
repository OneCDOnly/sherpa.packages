#!/usr/bin/env bash
#* <?dont_edit?>
#
#* <?filename?>
#
#* <?copyright?>
#
#* Description:
#*   A library of common bash functions used by many sherpa QPKG service-scripts.
#*   Each QPKG has a copy for use only by that QPKG's service-script.
#
#* <?project?>
#
#* <?tested?>
#
#* <?license?>

set -o nounset -o pipefail
shopt -s extglob
[[ $- != *m* ]] || set +m			# Disable job control if-enabled (only needed for QTS 4.2.6).
ln -fns /proc/self/fd /dev/fd		# KLUDGE: `/dev/fd` isn't always created by QTS.
readonly r_service_library_version='<?build_date?>'

InitLibrary()
	{

	IsQNAP || exit

	[[ ${DEBUG_QPKG:-} = true ]] && debug=true || debug=false

	local re=''

	for re in \\bd\\b \\bD\\b \\bdebug\\b \\bdbug\\b \\bverbose\\b; do
		[[ $r_user_args_raw =~ $re ]] || continue
		debug=true
		break
	done

	UnsetError

	# Internal session constants.

		# Paths.

			readonly r_backup_path=$(/sbin/getcfg SHARE_DEF defVolMP -f /etc/config/def_share.info)/.qpkg_config_backup
			readonly r_opkg_path=/opt/bin:/opt/sbin
				export PATH=$r_opkg_path:$(/bin/sed "s|$r_opkg_path||" <<< "$PATH")
			readonly r_qpkg_path=$(/sbin/getcfg $r_qpkg_name Install_Path -f /etc/config/qpkg.conf)
				readonly r_qpkg_config_path=$r_qpkg_path/config
					export HOME=$r_qpkg_config_path
				readonly r_qpkg_temp_path=$r_qpkg_path/tmp

		# Pathfilenames.

			readonly r_appl_version_store_pathfile=$r_qpkg_path/version.stored
			readonly r_screen_conf_pathfile=$r_qpkg_path/screen.conf
			readonly r_service_action_pathfile=/var/log/$r_qpkg_name.action
			readonly r_service_log_pathfile=/var/log/$r_qpkg_name.log
			readonly r_service_result_pathfile=/var/log/$r_qpkg_name.result
			readonly r_service_screen_log_pathfile=/var/log/$r_qpkg_name.screen.log

		# Values.

			readonly r_chars_regular_prompt='$ '
				readonly r_chars_sudo_prompt="${r_chars_regular_prompt}sudo "
			readonly r_chars_super_prompt='# '
			readonly r_debug_log_datawidth=100
			readonly r_nas_firmware_version=$(/sbin/getcfg System Version -f /etc/config/uLinux.conf)
			readonly r_qpkg_version=$(/sbin/getcfg $r_qpkg_name Version -d unknown -f /etc/config/qpkg.conf)

	# NOTE: default session variables are set below, but may be customised in the InitService() function for each QPKG.

	# >>> Paths <<<

		pip_cache_path=undefined

		qpkg_repo_path=undefined

		qpkg_wheels_path=undefined

		venv_path=undefined

	# >>> Filenames <<<

		qpkg_ini_file=config.ini

	# >>> Pathfilenames <<<

		app_version_pathfile=undefined

		daemon_check_pathfile=undefined							# If set, look for this process name in RAM instead of $daemon_exec_pathfile.

		daemon_exec_pathfile=undefined							# The pathfilename of the main daemon. If $daemon_script_pathfile is set, then this will be the interpreter used to run the script.

		daemon_pid_pathfile=/var/run/$r_qpkg_name.pid

		daemon_script_pathfile=undefined						# When an interpreter is to be used, interpret this script.

		launcher_pathfile=undefined								# On-demand executables only (no daemon).

		qpkg_backup_pathfile=$r_backup_path/$r_qpkg_name.config.tar.gz

		qpkg_ini_pathfile=$r_qpkg_config_path/$qpkg_ini_file

		qpkg_ini_default_pathfile=$qpkg_ini_pathfile.def

		userlink_pathfile=undefined								# Applies to on-demand executables only.

		venv_pip_pathfile=undefined

		venv_python_pathfile=undefined

	# >>> Switches <<<

		allow_access_to_sys_packages=true

		can_restart_to_update=false								# If 'true', application files can be updated by restarting service-script.

		compare_release_filename=false							# If 'true', release package filename is used instead of last modified date to determine if new release is available. Need this for *arr packages, as they don't expose the "last modified" datetime of remote package files.

		daemon_pidfile_is_managed_by_app=false

		install_pip_deps=false

		package_is_exec=false									# If 'true', downloadable package is an executable file. If 'false', downloadable package is an archive that must be extracted-from.

		recheck_daemon_pid_after_kill=false						# If 'true', application PID is reconfirmed shortly after kill. Some applications switch to another PID during shutdown, then kill their main PID.

		recheck_daemon_pid_after_launch=false					# If 'true', application PID is reconfirmed shortly after initial launch. Some applications launch with one PID, then switch to another. Some just take a while to start.

		resolve_remote_url=false								# If 'true', URL must be retrieved from remote first, then parsed to get final URL.

		run_daemon_in_screen_session=false						# If 'true', daemon is always launched in a `screen` session, but will exit `screen` when it can.

		silence_pypi_errors=true								# If 'true', PyPI package processing errors won't be shown in system log.

	# >>> Values <<<

		daemon_port=0

		interpreter=undefined

		nice_daemon_to=0										# If non-zero, daemon proc is niced to this value on-launch.

		orig_daemon_service_script=undefined					# Specific to Entware binaries only.

		remote_arch=undefined

		source_arch=undefined

		source_git_branch=undefined

		source_git_branch_depth=undefined						# 'shallow' (depth 1) or 'single-branch' ... 'shallow' implies 'single-branch'.

		ui_listening_address=undefined

		ui_port=0

		ui_port_secure=0

		wait_pid_kill_seconds=10								# This value is adaptive (increases with system load average).

		wait_pid_start_seconds=10								# This value is adaptive (increases with system load average).

		watch_pid_kill_seconds=120								# This value is adaptive (increases with system load average).

		watch_pid_start_seconds=120								# This value is adaptive (increases with system load average).

		watch_pidfile_start_seconds=60							# This value is adaptive (increases with system load average).

		watch_port_check_seconds=120							# This value is adaptive (increases with system load average).

	# >>> URLs <<<

		remote_url=undefined

		source_git_url=undefined

	# >>> CMDs <<<

		daemon_launch_cmd=undefined

		get_app_version_cmd=undefined

		get_daemon_port_cmd=undefined

		get_ui_listening_address_cmd=undefined

		get_ui_port_cmd=undefined

		get_ui_port_secure_cmd=undefined

		get_ui_port_secure_enabled_test_cmd=undefined

# --- start of template for service-script ---

	# This is a type _ service-script.

	# NOTE: default session values are set in InitLibrary(): uncomment or copy to update/modify.

	# >>> Paths <<<

		# pip_cache_path=undefined

		# qpkg_repo_path=undefined

		# qpkg_wheels_path=undefined

		# venv_path=undefined

	# >>> Filenames <<<

		# qpkg_ini_file=config.ini

	# >>> Pathfilenames <<<

		# app_version_pathfile=undefined

		# daemon_check_pathfile=undefined							# If set, look for this process name in RAM instead of $daemon_exec_pathfile.

		# daemon_exec_pathfile=undefined							# The pathfilename of the main daemon. If $daemon_script_pathfile is set, then this will be the interpreter used to run the script.

		# daemon_pid_pathfile=/var/run/$r_qpkg_name.pid

		# daemon_script_pathfile=undefined							# When an interpreter is to be used, interpret this script.

		# launcher_pathfile=undefined								# On-demand executables only (no daemon).

		# qpkg_backup_pathfile=$r_backup_path/$r_qpkg_name.config.tar.gz

		# qpkg_ini_pathfile=$r_qpkg_config_path/$qpkg_ini_file

		# qpkg_ini_default_pathfile=$qpkg_ini_pathfile.def

		# userlink_pathfile=undefined								# Applies to on-demand executables only.

		# venv_pip_pathfile=undefined

		# venv_python_pathfile=undefined

	# >>> Switches <<<

		# allow_access_to_sys_packages=true

		# can_restart_to_update=false								# If 'true', application files can be updated by restarting service-script.

		# compare_release_filename=false							# If 'true', release package filename is used instead of last modified date to determine if new release is available. Need this for *arr packages, as they don't expose the "last modified" datetime of remote package files.

		# daemon_pidfile_is_managed_by_app=false

		# install_pip_deps=false

		# package_is_exec=false										# If 'true', downloadable package is an executable file. If 'false', downloadable package is an archive that must be extracted-from.

		# recheck_daemon_pid_after_kill=false						# If 'true', application PID is reconfirmed shortly after kill. Some applications switch to another PID during shutdown, then kill their main PID.

		# recheck_daemon_pid_after_launch=false						# If 'true', application PID is reconfirmed shortly after initial launch. Some applications launch with one PID, then switch to another. Some just take a while to start.

		# resolve_remote_url=false									# If 'true', URL must be retrieved from remote first, then parsed to get final URL.

		# run_daemon_in_screen_session=false						# If 'true', daemon is always launched in a `screen` session, but will exit `screen` when it can.

		# silence_pypi_errors=true									# If 'true', PyPI package processing errors won't be shown in system log.

	# >>> Values <<<

		# daemon_port=0

		# interpreter=undefined

		# nice_daemon_to=0											# If non-zero, daemon proc is niced to this value on-launch.

		# orig_daemon_service_script=undefined						# Specific to Entware binaries only.

		# remote_arch=undefined

		# source_arch=undefined

		# source_git_branch=undefined

		# source_git_branch_depth=undefined							# 'shallow' (depth 1) or 'single-branch' ... 'shallow' implies 'single-branch'.

		# ui_listening_address=undefined

		# ui_port=0

		# ui_port_secure=0

		# wait_pid_kill_seconds=10									# This value is adaptive (increases with system load average).

		# wait_pid_start_seconds=10									# This value is adaptive (increases with system load average).

		# watch_pid_kill_seconds=120								# This value is adaptive (increases with system load average).

		# watch_pid_start_seconds=120								# This value is adaptive (increases with system load average).

		# watch_pidfile_start_seconds=60							# This value is adaptive (increases with system load average).

		# watch_port_check_seconds=120								# This value is adaptive (increases with system load average).

	# >>> URLs <<<

		# remote_url=undefined

		# source_git_url=undefined

	# >>> CMDs <<<

		# daemon_launch_cmd=undefined

		# get_app_version_cmd=undefined

		# get_daemon_port_cmd=undefined

		# get_ui_listening_address_cmd=undefined

		# get_ui_port_cmd=undefined

		# get_ui_port_secure_cmd=undefined

		# get_ui_port_secure_enabled_test_cmd=undefined

# --- end of template for service-script ---

	InitService					# Located in each parent QPKG service-script. Service-script variables will override the variables set above.

	OSIsSupportSecureDownload && curl_insecure_arg='' || curl_insecure_arg=' --insecure'
	get_remote_filename_timeout_seconds=5
	new_env=false
	pyver=''
	service_action=unspecified
	service_result=undefined
	MakePaths
	EnsureConfigFileExists
	GetAppVersion
	DisableOpkgDaemonStart
	IsSupportAutoUpdate && IsAutoUpdateMissing && EnableAutoUpdate >/dev/null

	if [[ $run_daemon_in_screen_session = true && ! -e $r_screen_conf_pathfile ]]; then
		echo -e "logfile ${r_service_screen_log_pathfile}\nlogfile flush 1\nlog on" > "$r_screen_conf_pathfile"
	fi

	}

StartQPKG()
	{

	IsNotError || return

	if IsReinstall || IsUpgrade; then		# Don't start QPKG when these actions are run from sherpa. If QPKG is disabled, then upgraded/reinstalled, the service result will be 'failed' (which is techically correct as the last action after upgrade is 'start', but probably better to see the upgrade or reinstall result instead).
		return
	fi

	IsNotStart && IsNotRestart && QPKGWasNotActive && return	# Don't start (after running actions like 'backup') if daemon wasn't active before.
	IsNotRestart && IsDaemon && IsDaemonActive && return		# No-need to check for an active daemon during 'restart' as it has already been killed.
	IsStart && ShowQPKGStates

	if [[ $(type -t StartQPKGCustom) = function ]]; then
		StartQPKGCustom
	else
		StartQPKGLibrary
	fi

	}

StartQPKGLibrary()
	{

	if IsGitApp; then
		CloneGitRepo || return
	fi

	if IsOnlineReleasePackage; then
		RefreshReleasePackageFiles || return
	fi

	if IsVirtualPythonEnv && IsNotVirtualPythonEnvExist; then
		CreateVirtualPythonEnv || return
		InstallPythonPackages || return
	fi

	if IsNotDaemon; then
		CreateUserlinkToExec
		return
	fi

	EnsureConfigFileExists
	LoadPorts app || return
	CheckPortsAvailable || return
	StartDaemon

	return

	}

StopQPKG()
	{

	IsNotError || return
	IsNotRestart && IsDaemon && IsNotDaemonActive && return

	if IsStop || IsRestart; then
		ShowQPKGStates
	fi

	if [[ $(type -t StopQPKGCustom) = function ]]; then
		StopQPKGCustom
	else
		StopQPKGLibrary
	fi

	}

StopQPKGLibrary()
	{

	if IsNotDaemon; then
		RemoveUserlinkToExec
		return
	fi

	RefreshPidFile

	if IsDaemon && IsDaemonActive; then
		SetQPKGWasActive
		StopDaemon
	fi

	return

	}

StatusQPKG()
	{

	IsNotError || return
	ShowQPKGStates

	if [[ $(type -t StatusQPKGCustom) = function ]]; then
		StatusQPKGCustom
	else
		StatusQPKGLibrary
	fi

	}

StatusQPKGLibrary()
	{

	# The following only checks for daemon services, and only HTTP/S port responses (where-applicable).
	# Any other status checks must be customised for the application and placed in StatusQPKGCustom() in the QPKG service-script.

	RefreshPidFile

	if IsDaemon && IsDaemonActive; then
		LoadPorts app
		CheckPorts || exit
	else
		exit 1
	fi

	exit 0

	}

CreateUserlinkToExec()
	{

	# Inputs: (global)
	#	$launcher_pathfile
	#	$r_qpkg_name
	#	$userlink_pathfile

	if [[ $userlink_pathfile != undefined ]]; then
		if [[ ! -L $userlink_pathfile && -e $launcher_pathfile ]]; then
			ln -s "$launcher_pathfile" "$userlink_pathfile"

			if [[ -L $userlink_pathfile ]]; then
				DisplayCommitToLog "= symlink created: '$userlink_pathfile'"
			else
				DisplayErrCommitAllLogs "= unable to create symlink to '$r_qpkg_name' launcher"

				SetError; return 1
			fi
		else
			DisplayCommitToLog "- symlink exists: '$userlink_pathfile'"
		fi

		return
	fi

	}

RemoveUserlinkToExec()
	{

	# Inputs: (global)
	#	$userlink_pathfile

	if [[ $userlink_pathfile != undefined ]]; then
		if [[ -L $userlink_pathfile ]]; then
			rm -f "$userlink_pathfile"
			DisplayCommitToLog "= symlink removed: '$userlink_pathfile'"
		fi
	fi

	}

CreateVirtualPythonEnv()
	{

	# Inputs: (global)
	#	$allow_access_to_sys_packages
	#	$interpreter
	#	$pip_cache_path
	#	$qpkg_wheels_path
	#	$venv_path

	# Outputs: (global)
	#   $new_env = true: new virtual environment was created.
	#   		 = false: a virtual environment already exists.

	new_env=false
	local a=''
	local b=$venv_path/pip.conf

	[[ $allow_access_to_sys_packages = true ]] && a=' --system-site-packages'

	if IsNotVirtualPythonEnvExist; then
		DisplayRunAndLog 'create new virtual Python environment' "export PIP_CACHE_DIR=$pip_cache_path VIRTUALENV_OVERRIDE_APP_DATA=$pip_cache_path; $interpreter -m virtualenv ${venv_path}${a}" log:failure-only
		new_env=true

		if [[ ! -e $b ]]; then
			DisplayRunAndLog "create QPKG 'pip' config" "echo \"[global]\" > $b" log:failure-only
			DisplayRunAndLog "add '$(/usr/bin/basename "$pip_cache_path")' as 'pip' cache" "echo \"cache-dir = $pip_cache_path\" >> $b" log:failure-only

			if [[ -d $qpkg_wheels_path ]]; then
				DisplayRunAndLog "add '$(/usr/bin/basename "$qpkg_wheels_path")' to 'pip' search path" "echo \"find-links = $qpkg_wheels_path\" >> $b" log:failure-only
			fi
		fi
	fi

	return 0

	}

StartDaemon()
	{

	# Inputs: (global)
	#	$daemon_launch_cmd
	#	$nice_daemon_to
	#	$run_daemon_in_screen_session
	#	$r_service_screen_log_pathfile

	local a='start daemon'
	local b=$daemon_launch_cmd

	if [[ $run_daemon_in_screen_session = true ]]; then
		a+=' (in screen session)'
		rm -f "${r_service_screen_log_pathfile:?}"
	fi

	if ((nice_daemon_to != 0)) && ((nice_daemon_to >= -20)) && ((nice_daemon_to <= 19)) && [[ -e /opt/bin/nice ]]; then
		b="/opt/bin/nice -n $nice_daemon_to bash -c \"$daemon_launch_cmd\""
		DisplayCommitToLog "- nice daemon to: $nice_daemon_to"
	fi

	if ! DisplayRunAndLog "$a" "$b" log:failure-only "$run_daemon_in_screen_session"; then
		[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$r_service_screen_log_pathfile"

		SetError; return 1
	fi

	IsDaemonActive
	WatchForDaemonPid
	WaitForStartPid

	if ! IsDaemonActive; then
		DisplayErrCommitAllLogs 'daemon has failed to start!'
		[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$r_service_screen_log_pathfile"

		SetError; return 1
	fi

	if ! CheckPorts; then
		DisplayErrCommitAllLogs 'port tests failed!'
		[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$r_service_screen_log_pathfile"

		SetError; return 1
	fi

	CommitInfoToSysLog "$a: OK"

	}

StopDaemon()
	{

	# Inputs: (global)
	#	$daemon_pid_pathfile
	#	$watch_pid_kill_seconds

	[[ -e $daemon_pid_pathfile ]] || return

	local a='stop daemon'
	local -i b=$(CalcAdaptiveSeconds "$watch_pid_kill_seconds")
	local -i c=0
	local -i d=$(<$daemon_pid_pathfile)

	[[ $d -gt 1 ]] || return

	DisplayWaitCommitToLog "> $a PID '${d}' with SIGTERM (no-more than $b second$(Pluralise "$b")):"

	kill "$d"

	while true; do
		while [[ -d /proc/$d ]]; do
			/bin/sleep 1
			((c++))
			DisplayWait "$c,"

			if [[ $c -ge $b ]]; then
				DisplayCommitToLog 'failed!'
				DisplayCommitToLog "> $a PID '${d}' with SIGKILL:"

				kill -9 "$d" 2> /dev/null

				[[ -f $daemon_pid_pathfile ]] && rm -f "$daemon_pid_pathfile"
				break 2
			fi
		done

		[[ -f $daemon_pid_pathfile ]] && rm -f "$daemon_pid_pathfile"

		Display OK
		CommitToLog "stopped in $c second$(Pluralise "$c")"

		CommitInfoToSysLog "$a: OK"
		break
	done

	WaitForKillPid

	if IsDaemonActive; then
		SetError; return 1
	fi

	}

RefreshReleasePackageFiles()
	{

	# Inputs: (global)
	#	$compare_release_filename
	#	$get_remote_filename_timeout_seconds
	#	$qpkg_repo_path
	#	$r_qpkg_temp_path
	#	$remote_arch
	#	$remote_url
	#	$resolve_remote_url

	local extract_release_package=false
	local refresh_release_package=false
	local release_package_filename=''
	local release_package_name_ref_pathfilename=''
	local release_package_pathfile=$r_qpkg_temp_path/source.package			# Local filename of the remote application package.
	local release_package_url=''

	if IsAutoUpdate || [[ ! -e $release_package_pathfile ]]; then			# Get remote package - even when auto-update is disabled - if one doesn't exist locally.
		if [[ $resolve_remote_url = true ]]; then
			refresh_release_package=true

			DisplayWaitCommitToLog '> get latest release package URL:'

			if IsSiteUp "$remote_url"; then
				release_package_url=$(RequestLatestReleaseURL "$remote_url" "$remote_arch")

				if [[ -n $release_package_url ]]; then
					DisplayCommitToLog OK
					DisplayCommitToLog "- release package URL: '$release_package_url'"
				else
					DisplayErrCommitAllLogs '! unable to get latest remote release package URL'
				fi
			else
				DisplayErrCommitAllLogs '! unable to access remote site'
			fi
		else
			release_package_url=$remote_url
		fi

		if [[ $compare_release_filename = true ]]; then
			DisplayWaitCommitToLog "> get latest remote release package filename (no-more than $get_remote_filename_timeout_seconds seconds):"

			if IsSiteUp "$remote_url"; then
				release_package_filename=$(RequestLatestReleaseFilename "$remote_url" "$remote_arch")

				if [[ -n $release_package_filename ]]; then
					DisplayCommitToLog OK
					DisplayCommitToLog "- release package filename: '$release_package_filename'"
				else
					DisplayErrCommitAllLogs '! unable to get latest remote release package filename'
				fi
			else
				DisplayErrCommitAllLogs '! unable to access remote site'
			fi

			if [[ -z $release_package_filename && -n $release_package_url && $release_package_url != undefined ]]; then
				release_package_filename=$(/usr/bin/basename "$release_package_url")
			fi

			if [[ -z $release_package_name_ref_pathfilename && -n $release_package_filename && -n $release_package_url && $release_package_url != undefined ]]; then
				release_package_name_ref_pathfilename=$(/usr/bin/dirname "$release_package_pathfile")/$release_package_filename
			fi

			if [[ -n $release_package_filename && -n $release_package_name_ref_pathfilename ]]; then
				DisplayWaitCommitToLog '- release package name reference exists locally:'

				if [[ -e $release_package_name_ref_pathfilename ]]; then
					DisplayCommitToLog true
				else
					DisplayCommitToLog false
					refresh_release_package=true
					rm -f "$release_package_pathfile"
				fi
			fi
		fi
	fi

	DisplayWaitCommitToLog '- release package exists locally:'

	if [[ -e $release_package_pathfile ]]; then
		DisplayCommitToLog true
	else
		DisplayCommitToLog false
		refresh_release_package=true
	fi

	if [[ ! -e $release_package_pathfile && -n $release_package_url ]] || [[ $refresh_release_package = true ]]; then
		DownloadReleasePackage "$release_package_url" "$release_package_pathfile"

		if [[ -e $release_package_pathfile ]] && [[ ! -e $daemon_exec_pathfile || $(($(/bin/date +%s)-$(/usr/bin/stat "$release_package_pathfile" -c %Y))) -lt 10 ]]; then		# If release package was downloaded less-than 10 minutes ago, assume it's new and must therefore be extracted-from.
			extract_release_package=true
		fi
	fi

	if IsPathEmpty "$qpkg_repo_path"; then
		extract_release_package=true
	fi

	if [[ $extract_release_package = true && -e $release_package_pathfile ]]; then
		if IsReleaseAnArchive; then
			ExtractReleasePackage "$release_package_pathfile" "$release_package_name_ref_pathfilename"
		else
			MakeExecReleasePackage "$release_package_pathfile" "$release_package_name_ref_pathfilename"
		fi
	fi

	if [[ -d $qpkg_repo_path ]]; then
		if IsPathEmpty "$qpkg_repo_path"; then
			DisplayErrCommitAllLogs "'local repository files do not exist'"

			SetError; return 1
		fi
	else
		DisplayErrCommitAllLogs "'local repository path does not exist'"

		SetError; return 1
	fi

	return 0

	}

CheckPortsAvailable()
	{

	# Inputs: (global)
	#	$daemon_port
	#	$ui_port
	#	$ui_port_secure

	local a=''

	if [[ $daemon_port -le 0 && $ui_port -le 0 && $ui_port_secure -le 0 ]]; then
		DisplayErrCommitAllLogs "'no port specified'"

		SetError; return 1
	elif IsNotPortAvailable $ui_port || IsNotPortAvailable $ui_port_secure; then
		DisplayErrCommitAllLogs "ports '$ui_port' or '$ui_port_secure' are already in-use"

		a=$(/usr/sbin/lsof -i :$ui_port -Fp)
		DisplayErrCommitAllLogs "- process details for port '$ui_port': '${a}': PID '$([[ -n ${a:-} ]] && /bin/tr '\000' ' ' </proc/"${a/p/}"/cmdline)'"

		a=$(/usr/sbin/lsof -i :$ui_port_secure -Fp)
		DisplayErrCommitAllLogs "- process details for secure port '$ui_port_secure': PID '${a}': '$([[ -n ${a:-} ]] && /bin/tr '\000' ' ' </proc/"${a/p/}"/cmdline)'"

		SetError; return 1
	fi

	}

ShowHelp()
	{

	# Inputs: (global)
	#	$r_qpkg_name
	#	$r_service_script_version

	Display "$(TextBrightWhite "$(/usr/bin/basename "$0")") v$r_service_script_version • a service control script for the $(FormatAsPackageName $r_qpkg_name) QPKG"
	Display
	Display "Usage: $0 [ACTION] [OPTION]"
	Display
	Display '[ACTION] must be one of the following:'
	DisplayAsHelp 'activate, start' "start $(FormatAsPackageName $r_qpkg_name) if inactive"
	IsSupportBackup && DisplayAsHelp 'b, backup' "backup current $(FormatAsPackageName $r_qpkg_name) configuration to persistent storage"
	IsSourcedOnline && DisplayAsHelp clean "delete & re-download $(FormatAsPackageName $r_qpkg_name) files from source. Configuration will be retained"
	DisplayAsHelp 'deactivate, stop' "stop $(FormatAsPackageName $r_qpkg_name) if active"
	DisplayAsHelp disable "disable $(FormatAsPackageName $r_qpkg_name) to prevent it starting (on NAS bootup)"
	IsSupportAutoUpdate && DisplayAsHelp disable-auto-update "don't auto-update $(FormatAsPackageName $r_qpkg_name) before starting it"
	DisplayAsHelp enable "enable $(FormatAsPackageName $r_qpkg_name) so it can be started"
	IsSupportAutoUpdate && DisplayAsHelp enable-auto-update "auto-update $(FormatAsPackageName $r_qpkg_name) before starting (default)"
	DisplayAsHelp 'l, L, log' 'display the service-script log'
	DisplayAsHelp 'r, reactivate, restart' "stop, then start $(FormatAsPackageName $r_qpkg_name)"
	IsSupportActions && DisplayAsHelp reset-action 'clear the current service-script action and action result'
	IsSupportReset && DisplayAsHelp reset-config "revert $(FormatAsPackageName $r_qpkg_name) configuration, databases and history to defaults"
	IsSupportBackup && DisplayAsHelp restore 'restore a previously saved configuration from persistent storage'
	DisplayAsHelp 's, status' "check if $(FormatAsPackageName $r_qpkg_name) application is active. Returns \$? = 0 if active, 1 if not"
	DisplayAsHelp 'v, V, version' 'display the package version numbers'
	Display
	Display '[OPTION] may be one of the following:'
	DisplayAsHelp 'd, D, debug, verbose' "execute the specified [ACTION] in debug mode"
	Display

	}

InstallPythonPackages()
	{

	# Inputs: (global)
	#	$app_version
	#	$r_appl_version_store_pathfile
	#	$install_pip_deps
	#	$new_env
	#	$r_qpkg_name
	#	$qpkg_repo_path
	#	$silence_pypi_errors
	#	$venv_pip_pathfile

	IsVirtualPythonEnv || return 0

	local a=''
	local cmd=''
	local default_essential_modules_pathfile=$r_qpkg_path/pip-essential.txt
	local default_recommended_modules_pathfile=$r_qpkg_path/pip-recommended.txt
	local default_requirements_modules_pathfile=$r_qpkg_path/pip-requirements.txt
	local essential_modules_pathfile=$qpkg_repo_path/pip-essential.txt
	local excluded_modules_pathfile=$r_qpkg_path/pip-exclusions.txt
	local module_exclusions=''
	local no_pip_deps=' --no-deps'
	local no_pips_installed=true
	local pyproject_pathfile=$qpkg_repo_path/pyproject.toml
	local re=''
	local recommended_modules_pathfile=$qpkg_repo_path/recommended.txt
	local rename_modules_pathfile=$r_qpkg_path/pip-rename.txt
	local requirements_modules_pathfile=$qpkg_repo_path/requirements.txt

	[[ $install_pip_deps = true ]] && no_pip_deps=''

	if IsNotVirtualPythonEnvExist; then
		DisplayErrCommitAllLogs "unable to install addons: 'virtual Python environment does not exist'"

		SetError; return 1
	fi

	IsNotAutoUpdate && [[ $new_env = false ]] && return 0

	if [[ $r_qpkg_name = OWatcher3 ]]; then
		# Need to install `m2r` PyPI module first.
		DisplayRunAndLog "KLUDGE: install 'm2r' PyPI module first" "$venv_pip_pathfile install${no_pip_deps} --no-input m2r" log:failure-only

		if [[ $? -gt 0 && $silence_pypi_errors = false ]]; then
			CommitWarnToSysLog "'mr2' PyPI module installation failed."
		fi
	fi

	# Edit developer-provided Python module requirements files out-of-repo.
	# NOTE: Always prefer QPKG-supplied PyPI lists over repo-supplied versions.

	[[ ! -e $default_essential_modules_pathfile && -e $essential_modules_pathfile && -d $(/usr/bin/dirname "$default_essential_modules_pathfile") ]] && cp -f "$essential_modules_pathfile" "$default_essential_modules_pathfile"
	[[ -e $default_essential_modules_pathfile ]] && essential_modules_pathfile=$default_essential_modules_pathfile

	[[ ! -e $default_requirements_modules_pathfile && -e $requirements_modules_pathfile && -d $(/usr/bin/dirname "$default_requirements_modules_pathfile") ]] && cp -f "$requirements_modules_pathfile" "$default_requirements_modules_pathfile"
	[[ -e $default_requirements_modules_pathfile ]] && requirements_modules_pathfile=$default_requirements_modules_pathfile

	[[ ! -e $default_recommended_modules_pathfile && -e $recommended_modules_pathfile && -d $(/usr/bin/dirname "$default_recommended_modules_pathfile") ]] && cp -f "$recommended_modules_pathfile" "$default_recommended_modules_pathfile"
	[[ -e $default_recommended_modules_pathfile ]] && recommended_modules_pathfile=$default_recommended_modules_pathfile

	# Must remove these modules from repo txt files, and use the ones installed via `opkg` instead (if-available).
	# If not, `pip` will attempt to compile these, which fails on various arches.

	if [[ -e $excluded_modules_pathfile ]]; then
		module_exclusions=$(/bin/tr '\n' ' ' <<< "$(StripComments "$(<"$excluded_modules_pathfile")")")
		module_exclusions=${module_exclusions%* }

		if [[ -n $module_exclusions ]]; then
			re="^${module_exclusions// /\$\|^}$"			# Match whole line.

# Let's leave the version and arch specifiers alone.
# 			for a in '\=' '\~' '\<' '\>' '\!' '\[' ' '; do	# Add regexes for multiple patterns.
# 				re+="|^${module_exclusions// /$a\|^}"
# 			done
		fi

		if [[ -n $re ]]; then
			for a in $essential_modules_pathfile $requirements_modules_pathfile $recommended_modules_pathfile $pyproject_pathfile; do
				if [[ -e $a ]]; then
					if [[ -e /opt/bin/sed ]]; then
						cmd="/opt/bin/sed -i '/${re}/Id' $a"	# Perform case-insensitive matching only if GNU `sed` exists.
					else
						cmd="/bin/sed -i '/${re}/d' $a"			# Eh, hope for the best.
					fi

					DisplayRunAndLog "exclude problematic PyPI modules from '$(/usr/bin/basename "$a")'" "$cmd" log:failure-only
				fi
			done
		fi
	fi

	# Install PyPI modules.

	for a in $essential_modules_pathfile $requirements_modules_pathfile $recommended_modules_pathfile; do
		if [[ -e $a ]]; then
			DisplayRunAndLog "install PyPI modules from '$(/usr/bin/basename "$a")'" "$venv_pip_pathfile install${no_pip_deps} --no-input --upgrade pip -r $a" log:failure-only

			if [[ $? -gt 0 && $silence_pypi_errors = false ]]; then
				CommitWarnToSysLog '= PyPI module installation failed.'
			fi

			no_pips_installed=false
		fi
	done

	# KLUDGE: `manytolinux2014` builds are problematic in QTS, so rename these locally.

	if [[ -e $rename_modules_pathfile ]]; then
		for a in $(StripComments "$(<"$rename_modules_pathfile")"); do
			RenameSharedObjectFile "$a"
		done
	fi

	if IsSupportGetAppVersion; then
		GetAppVersion

		if [[ $new_env = false && -e $r_appl_version_store_pathfile && $(<"$r_appl_version_store_pathfile") != "$app_version" ]]; then
			# Remove existing .pyc files to prevent runtime errors
			DisplayRunAndLog 'clean Python bytecode files' "/opt/bin/find $qpkg_repo_path -type d -name '__pycache__' -print0 | xargs -I {} -0 rm -rf '{}'
" log:failure-only
		fi

		if [[ ! -e $r_appl_version_store_pathfile || $(<"$r_appl_version_store_pathfile") != "$app_version" ]]; then
			# Generate language translations.
			DisplayRunAndLog 'generate language translations' "cd $qpkg_repo_path; $venv_python_pathfile $qpkg_repo_path/tools/make_mo.py" log:failure-only
		fi

		SaveAppVersion
	fi

	return 0

	}

StripComments()
	{

	# Inputs: (local)
	#   $1 = String to strip comment lines, empty lines, and so-on.

	# Outputs: (local)
	#   stdout

	[[ -n $1 ]] || return

	local a=$1

	a=$(/bin/sed -e '/^#[[:space:]].*/d;/#$/d;s/[[:space:]]#[[:space:]].*//' <<< "$a")		# Remove comment lines and line comments.
	a=$(/bin/sed -e 's/^[[:space:]]*//' <<< "$a")											# Remove leading whitespace.
	a=$(/bin/sed 's/[[:space:]]*$//' <<< "$a")												# Remove trailing whitespace.
	a=$(/bin/sed "/^$/d" <<< "$a")															# Remove empty lines.

	echo "$a"

	}

BackupConfig()
	{

	# Inputs: (global)
	#	$qpkg_backup_pathfile
	#	$r_qpkg_path

	if ! DisplayRunAndLog 'update configuration backup' "/bin/tar --create --gzip --file=$qpkg_backup_pathfile --directory=$r_qpkg_path/config ." log:failure-only; then
		SetError; return 1
	fi

	}

RestoreConfig()
	{

	# Inputs: (global)
	#	$qpkg_backup_pathfile
	#	$r_qpkg_path

	if [[ ! -f $qpkg_backup_pathfile ]]; then
		DisplayErrCommitAllLogs "unable to restore configuration: 'no backup file was found'"

		SetError; return 1
	fi

	if ! DisplayRunAndLog 'restore configuration backup' "/bin/tar --extract --gzip --file=$qpkg_backup_pathfile --directory=$r_qpkg_path/config" log:failure-only; then
		SetError; return 1
	fi

	}

ResetConfig()
	{

	# Inputs: (global)
	#	$qpkg_ini_default_pathfile
	#	$r_qpkg_path

	if ! DisplayRunAndLog 'reset configuration' "mv $qpkg_ini_default_pathfile $r_qpkg_path; rm -rf $r_qpkg_path/config/*; mkdir -p $(/usr/bin/dirname "$qpkg_ini_default_pathfile"); mv $r_qpkg_path/$(/usr/bin/basename "$qpkg_ini_default_pathfile") $qpkg_ini_default_pathfile" log:failure-only; then
		SetError; return 1
	fi

	}

MakePaths()
	{

	# Inputs: (global)
	#	$r_backup_path
	#	$pip_cache_path
	#	$r_qpkg_path
	#	$qpkg_repo_path
	#	$r_qpkg_temp_path
	#	$venv_path

	local a=''

	if [[ -d $r_qpkg_path ]]; then
		for a in "$r_qpkg_temp_path" "$qpkg_repo_path" "$pip_cache_path" "$venv_path"; do
			[[ $a != undefined && ! -d $a ]] && mkdir -p "$a"
		done
	fi

	[[ $r_backup_path != undefined && ! -d $r_backup_path ]] && mkdir -p "$r_backup_path"

	}

LoadPorts()
	{

	# If user changes ports via application UI, must first 'stop' application on old ports, then 'start' on new ports.

	# Inputs: (local)
	#	$1 = source location of ports.

	# Inputs: (global)
	#	$get_daemon_port_cmd
	#	$get_ui_listening_address_cmd
	#	$get_ui_port_cmd
	#	$get_ui_port_secure_cmd
	#	$r_qpkg_name

	# Outputs: (global)
	#	$daemon_port
	#	$ui_listening_address
	#	$ui_port
	#	$ui_port_secure

	case $1 in
		app)
			# Read the current application UI ports from application configuration.
			DisplayWaitCommitToLog '> load ports from configuration file:'
			[[ $get_ui_port_cmd != undefined ]] && ui_port=$(eval "$get_ui_port_cmd")
			[[ $get_ui_port_secure_cmd != undefined ]] && ui_port_secure=$(eval "$get_ui_port_secure_cmd")
			DisplayCommitToLog OK
			;;
		qts)
			# Read the current application UI ports from QTS App Center.
			DisplayWaitCommitToLog '> load UI ports from QPKG icon:'
			ui_port=$(/sbin/getcfg $r_qpkg_name Web_Port -d 0 -f /etc/config/qpkg.conf)
			ui_port_secure=$(/sbin/getcfg $r_qpkg_name Web_SSL_Port -d 0 -f /etc/config/qpkg.conf)
			DisplayCommitToLog OK
			;;
		*)
			DisplayErrCommitAllLogs "unable to load ports: action '$1' is unrecognised"

			SetError; return 1
	esac

	# Always read these from the application configuration file.
	[[ $get_daemon_port_cmd != undefined ]] && daemon_port=$(eval "$get_daemon_port_cmd")
	[[ $get_ui_listening_address_cmd != undefined ]] && ui_listening_address=$(eval "$get_ui_listening_address_cmd")

	# Validate port numbers.

	ui_port=${ui_port//[!0-9]/}					# Strip all non-numerals.
	[[ -z $ui_port || $ui_port -lt 0 || $ui_port -gt 65535 ]] && ui_port=0

	ui_port_secure=${ui_port_secure//[!0-9]/}	# Strip all non-numerals
	[[ -z $ui_port_secure || $ui_port_secure -lt 0 || $ui_port_secure -gt 65535 ]] && ui_port_secure=0

	daemon_port=${daemon_port//[!0-9]/}			# Strip all non-numerals.
	[[ -z $daemon_port || $daemon_port -lt 0 || $daemon_port -gt 65535 ]] && daemon_port=0

	[[ -z $ui_listening_address ]] && ui_listening_address=undefined
	return 0

	}

GetAppVersion()
	{

	# Find the application's internal version number. This is the installed application version (not the QPKG version).

	# Inputs: (global)
	#	$app_version_pathfile
	#	$get_app_version_cmd

	# Output (global):
	#   $app_version

	if IsSupportGetAppVersion && [[ -e $app_version_pathfile ]]; then
		app_version=$(eval "$get_app_version_cmd")
		return 0
	else
		app_version=unknown
		return 1
	fi

	}

ShowQPKGStates()
	{

	# Inputs: (global)
	#	$qpkg_repo_path

	DisplayWaitCommitToLog '- QPKG enabled:'

	if IsQPKGEnabled; then
		DisplayCommitToLog true
	else
		DisplayCommitToLog false
	fi

	if IsSupportAutoUpdate; then
		DisplayWaitCommitToLog '- application auto-update:'

		if IsAutoUpdate; then
			DisplayCommitToLog true
		else
			DisplayCommitToLog false
		fi
	fi

	if IsGitApp; then
		DisplayCommitToLog "- active git branch: '$(GetPathGitBranch "$qpkg_repo_path")'"
	fi

	}

DisableOpkgDaemonStart()
	{

	# Inputs: (global)
	#	$orig_daemon_service_script

	if [[ $orig_daemon_service_script != undefined && -x $orig_daemon_service_script ]]; then
		$orig_daemon_service_script stop		# Stop default daemon,
		chmod -x "$orig_daemon_service_script"	# ... and ensure Entware doesn't re-launch it on startup.
	fi

	}

CloneGitRepo()
	{

	# Inputs: (global)
	#   $r_qpkg_name
	#   $qpkg_repo_path
	#   $source_git_branch
	#   $source_git_branch_depth
	#   $source_git_url

	IsGitApp || return 0

	local active_branch=$(GetPathGitBranch "$qpkg_repo_path")
	local branch_depth='--depth 1'
	[[ $source_git_branch_depth = single-branch ]] && branch_depth='--single-branch'
	local branch_switch=false
	local new_branch=false

	WatchForGit || return

	if [[ -d $qpkg_repo_path/.git ]]; then
		if [[ $active_branch != "$source_git_branch" ]]; then
			DisplayCommitToLog "- new git branch specified: '$source_git_branch'"
			branch_switch=true
			[[ $r_qpkg_name = nzbToMedia ]] && BackupConfig
			CleanLocalRepo
		fi
	fi

	if [[ ! -d $qpkg_repo_path/.git ]]; then
		DisplayRunAndLog "create $(FormatAsPackageName "$r_qpkg_name") from remote repository" "cd /tmp; /opt/bin/git clone --branch $source_git_branch $branch_depth -c advice.detachedHead=false $source_git_url $qpkg_repo_path" log:failure-only
		new_branch=true
	else
		if IsAutoUpdate; then
			# Latest effort at resolving local clone corruption: https://stackoverflow.com/a/10170195
			DisplayRunAndLog "update $(FormatAsPackageName "$r_qpkg_name") from remote repository" "cd /tmp; /opt/bin/git -C $qpkg_repo_path clean -f; /opt/bin/git -C $qpkg_repo_path reset --hard origin/$source_git_branch; /opt/bin/git -C $qpkg_repo_path pull" log:failure-only
		fi
	fi

	IsAutoUpdate && [[ $new_branch = true || $branch_switch = true ]] && DisplayCommitToLog "- active git branch: '$(GetPathGitBranch "$qpkg_repo_path")'"
	[[ $branch_switch = true && $r_qpkg_name = nzbToMedia ]] && RestoreConfig

	return 0

	}

CleanLocalRepo()
	{

	# For occasions where the local repo needs to be deleted and cloned again from source.

	# Inputs: (global)
	#   $r_appl_version_store_pathfile
	#   $pip_cache_path
	#   $r_qpkg_name
	#	$r_qpkg_path
	#   $qpkg_repo_path
	#   $r_qpkg_temp_path
	#   $venv_path

	if [[ -z $r_qpkg_path || -z $r_qpkg_name ]] || IsNotSourcedOnline; then
		SetError; return 1
	fi

	(IsGitApp || IsOnlineReleasePackage) && DisplayRunAndLog 'clean local repository' "rm -rf \"$qpkg_repo_path\"" log:failure-only
	IsVirtualPythonEnv && [[ -d $venv_path ]] && DisplayRunAndLog 'clean virtual Python environment' "rm -rf \"$venv_path\"" log:failure-only
	IsUsePipCache && [[ -d $pip_cache_path ]] && DisplayRunAndLog 'clean PyPI cache' "rm -rf \"$pip_cache_path\"" log:failure-only
	[[ -e $r_appl_version_store_pathfile ]] && DisplayRunAndLog 'remove application version' "rm -f \"$r_appl_version_store_pathfile\"" log:failure-only
	IsUseTemp && [[ -d $r_qpkg_temp_path ]] && DisplayRunAndLog 'clean temp path' "rm -rf \"$r_qpkg_temp_path\"" log:failure-only

	MakePaths

	}

WatchForGit()
	{

	# Inputs: (global)
	#   $r_opkg_path
	#   $PATH

	# Outputs: (global)
	#   $PATH

	if IsNotQPKGInstalled Entware; then
		DisplayErrCommitAllLogs "'git' unavailable: 'Entware is not installed'"
		SetError; return 1
	fi

	if IsNotQPKGEnabled Entware; then
		DisplayErrCommitAllLogs "'git' unavailable: 'Entware is not enabled'"
		SetError; return 1
	fi

	if WatchForFileToAppear /opt/bin/git 300; then
		export PATH=$r_opkg_path:$(/bin/sed "s|$r_opkg_path||" <<< "$PATH")
		return 0
	fi

	SetError; return 1

	}

RefreshPidFile()
	{

	# Inputs: (global)
	#   $daemon_check_pathfile
	#   $daemon_exec_pathfile
	#   $daemon_pid_pathfile
	#	$daemon_script_pathfile

	# Outputs:
	#   stdout > $daemon_pid_pathfile

	local -i a=0

	if [[ -e $daemon_pid_pathfile && ! -d /proc/"$(<$daemon_pid_pathfile)" ]]; then
		rm -f "$daemon_pid_pathfile"
	fi

	if [[ $daemon_check_pathfile != undefined ]]; then
		a=$(FindPid "$daemon_check_pathfile")
	else
		a=$(FindPid "$daemon_exec_pathfile" "$daemon_script_pathfile")
	fi

	[[ -n $a && $a -gt 0 ]] && echo "$a" > "$daemon_pid_pathfile"

	}

FindPid()
	{

	# Inputs: (local)
	#   $1 = Process pathfilename to find.
	#   $2 (optional) = additional string to match if there are multiple processes with identical pathfilenames.

	# Outputs: (local)
	#   $? = 0 (found) or 1 (not found)
	#	stdout = PID

	[[ -n ${1:-} ]] || return

	local -i a=0
	local b=''

	[[ -n ${2:-} && $2 != undefined ]] && b=$2

	for a in $(/bin/pidof "$(/usr/bin/basename "$1")"); do
		[[ $a -gt 1 ]] || continue
		[[ -d /proc/$a ]] || continue
		[[ -e /proc/$a/cmdline && -L /proc/$a/exe ]] || continue
		[[ $(</proc/$a/cmdline) =~ $1 || $(/usr/bin/readlink /proc/$a/exe) = "$1" ]] || continue

		if [[ -n $b ]]; then
			[[ $(</proc/$a/cmdline) =~ $b ]] || continue	# Check for additional string (if-specified).
		fi

		printf '%s' "$a"

		return
	done

	return 1

	}

WaitForStartPid()
	{

	# Inputs: (global)
	#   $daemon_pid_pathfile
	#   $daemon_pidfile_is_managed_by_app
	#   $recheck_daemon_pid_after_launch
	#   $wait_pid_start_seconds
	#	$watch_pidfile_start_seconds

	local -i a=$(CalcAdaptiveSeconds "$wait_pid_start_seconds")
	local -i i=0

	if [[ $daemon_pidfile_is_managed_by_app = true ]]; then
		if WatchForFileToAppear "$daemon_pid_pathfile" "$(CalcAdaptiveSeconds "$watch_pidfile_start_seconds")"; then
			/bin/sleep 1		# Wait one more second to allow file to have PID written into it.
		fi
	fi

	if [[ $recheck_daemon_pid_after_launch = true ]]; then
		DisplayWaitCommitToLog "> wait $a second$(Pluralise "$a") to recheck PID:"

		for ((i=1; i<=a; i++)); do
			/bin/sleep 1
			DisplayWait "$i,"
		done

		DisplayCommitToLog 'done'
	fi

	RefreshPidFile || return

	}

WaitForKillPid()
	{

	# Inputs: (global)
	#   $recheck_daemon_pid_after_kill
	#   $wait_pid_kill_seconds

	local -i a=$(CalcAdaptiveSeconds "$wait_pid_kill_seconds")
	local -i i=0

	if [[ $recheck_daemon_pid_after_kill = true ]]; then
		DisplayWaitCommitToLog "> wait $a second$(Pluralise "$a") to recheck PID:"

		for ((i=1; i<=a; i++)); do
			/bin/sleep 1
			DisplayWait "$i,"
		done

		DisplayCommitToLog 'done'
	fi

	! RefreshPidFile || return

	}

WatchForDaemonPid()
	{

	# Inputs: (global)
	#   $daemon_pid_pathfile
	#	$watch_pid_start_seconds

	# Outputs: (local)
	#   $? = 0 (file was found) or 1 (file not found: timeout)

	local -i a=$(CalcAdaptiveSeconds "$watch_pid_start_seconds")
	local -i i=0

	if [[ ! -e $daemon_pid_pathfile ]]; then
		DisplayWaitCommitToLog "> watch for daemon process name to appear (no-more than $a second$(Pluralise "$a")):"

		(
			for ((i=1; i<=a; i++)); do
				/bin/sleep 1
				DisplayWait "$i,"

				RefreshPidFile

				if IsDaemonProcessActive; then
					Display OK
					CommitToLog "appeared in $i second$(Pluralise "$i")"
					true

					exit	# Only this sub-shell.
				fi
			done

			false
		)

		if [[ $? -ne 0 ]]; then
			DisplayErrCommitAllLogs "process name not found! (exceeded timeout: $a second$(Pluralise "$a"))"
			return 1
		fi
	fi

	return 0

	}

WatchForFileToAppear()
	{

	# Inputs: (local)
	#   $1 = pathfilename to watch-for.
	#   $2 (optional) = timeout in seconds - default 30

	# Outputs: (local)
	#   $? = 0 : file was found
	#   $? = 1 : file not found/timeout

	[[ -n $1 ]] || return

	local -i a=0
	local -i i=0

	if [[ -n $2 ]]; then
		a=$2
	else
		a=30
	fi

	if [[ ! -e $1 ]]; then
		DisplayWaitCommitToLog "> watch for $1 to appear in filesystem (no-more than $a second$(Pluralise "$a")):"

		(
			for ((i=1; i<=a; i++)); do
				/bin/sleep 1
				DisplayWait "$i,"

				if [[ -e $1 ]]; then
					Display OK
					CommitToLog "visible after $i second$(Pluralise "$i")"
					true

					exit	# Only this sub-shell.
				fi
			done
			false
		)

		if [[ $? -ne 0 ]]; then
			DisplayErrCommitAllLogs "file $1 not found! (exceeded timeout: $a second$(Pluralise "$a"))"
			return 1
		fi
	fi

	DisplayCommitToLog "- file exists: '$1'"

	return 0

	}

ViewLog()
	{

	# Inputs: (global)
	#   $r_service_log_pathfile

	if [[ -e $r_service_log_pathfile ]]; then
		if [[ -e /opt/bin/less ]]; then
			LESSSECURE=1 /opt/bin/less +G --quit-on-intr --tilde --LINE-NUMBERS --RAW-CONTROL-CHARS --prompt ' use arrow-keys to scroll up-down left-right, press Q to quit' "$r_service_log_pathfile"
		else
			/bin/cat --number "$r_service_log_pathfile"
		fi
	else
		Display "service log not found: $r_service_log_pathfile"

		SetError; return 1
	fi

	return 0

	}

EnsureConfigFileExists()
	{

	# Inputs: (global)
	#   $qpkg_ini_default_pathfile
	#   $qpkg_ini_pathfile

	IsNotSupportReset && return

	if IsNotConfigFound && IsDefaultConfigFound; then
		DisplayCommitToLog '> no configuration file found: using default'
		cp "${qpkg_ini_default_pathfile:?undefined}" "${qpkg_ini_pathfile:?undefined}"
	fi

	}

SaveAppVersion()
	{

	# Inputs: (global)
	#   $app_version
	#   $r_appl_version_store_pathfile

	[[ $r_appl_version_store_pathfile != undefined ]] && echo "$app_version" > "$r_appl_version_store_pathfile"

	}

DisplayRunAndLog()
	{

	# Run a commandstring with a summarised description, log the results, and show onscreen if required.
	# This function is just a fancy wrapper for Executer()

	# Inputs: (local)
	#   $1 = Processing message.
	#   $2 = Commandstring to execute.
	#   $3 (optional) = 'log:failure-only' - if specified, stdout & stderr are only recorded in the specified log if the command failed. Default is to always record stdout & stderr.
	#   $4 (optional) = true/false - if true, run command in a `screen` session.

	# Inputs: (global)
	#   $debug

	local -r r_log_pathfile=$(/bin/mktemp /var/log/"${FUNCNAME[0]}"_XXXXXX)
	local -i z=0

	DisplayWaitCommitToLog "> $1:"

	Executer "${2:?empty}" "$r_log_pathfile" "${4:-false}"
	z=$?

	if [[ $z -eq 0 ]]; then
		if [[ $debug = false ]]; then
			DisplayCommitToLog OK
		else
			Display "= $1: OK"
			CommitToLog OK
		fi
	else
		if [[ $debug = false ]]; then
			DisplayCommitToLog failed
		else
			DisplayCommitToLog "= $1: failed"
		fi
	fi

	if [[ $z -eq 0 ]]; then
		[[ ${3:-} != log:failure-only ]] && AddFileToDebug "$r_log_pathfile"
	else
		AddFileToDebug "$r_log_pathfile"
	fi

	[[ -e $r_log_pathfile ]] && rm -f "$r_log_pathfile"
	return $z

	}

Executer()
	{

	# Run a commandstring, log the results, and show onscreen if-requested.

	# Inputs: (local)
	#   $1 = commandstring to execute.
	#   $2 = log pathfile to record stdout and stderr for commandstring.
	#   $3 (optional) = true/false - if true, run command in a `screen` session.

	# Inputs: (global)
	#	$debug
	#	$r_qpkg_name
	#	$r_screen_conf_pathfile
	#	$r_service_screen_log_pathfile

	# Outputs:
	#   stdout = commandstring stdout and stderr if script is in 'debug' mode.
	#   pathfile ($2) = commandstring ($1) stdout and stderr.
	#   $? = $result_code of commandstring.

	local -r r_log_pathfile=$(/bin/mktemp /var/log/"${FUNCNAME[0]}"_XXXXXX)
	local run_in_screen=${3:-false}
	local -i z=0

	FormatAsCommand "${1:?empty}" > "${2:?empty}"

	if [[ $run_in_screen = true ]]; then
		if [[ $debug = true ]]; then
			Display
			Display "{ exec (in screen session): '$1'"
		fi

		FormatAsCommand "$1" >> "$r_service_screen_log_pathfile"
		/usr/sbin/screen -c "$r_screen_conf_pathfile" -dmLS "$r_qpkg_name" bash -c "$1"
		z=$?
	elif [[ $debug = true ]]; then
		Display
		Display "{ exec: '$1'"
		eval "$1 > >(/usr/bin/tee $r_log_pathfile) 2>&1"		# NOTE: 'tee' buffers stdout here.
		z=${PIPESTATUS[0]}										# Must use $PIPESTATUS after `tee` to get returncode of previous command: https://stackoverflow.com/questions/1221833/pipe-output-and-capture-exit-status-in-bash
	else
		(eval "$1" > "$r_log_pathfile" 2>&1)					# Run in a subshell to suppress "Terminated" message later.
		z=$?
	fi

	if [[ -e $r_log_pathfile ]]; then
		FormatAsResultAndStdout "$z" "$(<"$r_log_pathfile")" >> "$2"
	else
		FormatAsResultAndStdout "$z" '<null>' >> "$2"
	fi

	if [[ $debug = true ]]; then
		if [[ $z -eq 0 ]]; then
			Display '} exec: completed OK'
		else
			Display '} exec: completed with errors'
		fi
	fi

	[[ -e $r_log_pathfile ]] && rm -f "$r_log_pathfile"
	return $z

	}

ShowEnabled()
	{

	DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG is enabled."

	}

ShowDisabled()
	{

	DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG is disabled."

	}

ShowDisabledPrompt()
	{

	DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG is disabled. Please enable it first with: $0 enable"

	}

ShowEnableFailed()
	{

	DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG enable failed."

	}

ShowDisableFailed()
	{

	DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG disable failed."

	}

AddFileToDebug()
	{

	# Add the contents of specified pathfile $1 to the runtime log.

	# Inputs: (local)
	#   $1 = pathfilename of log to add.

	# Inputs: (global)
	#   $debug

	# Outputs: (global)
	#   $debug

	[[ -e ${1:?no filename supplied} ]] || return

	local a=''
	local debug_was_set=$debug

	# Prevent external log contents appearing on-screen again, as they have already been seen "live".
	debug=false

	DebugAsLog ''
	DebugAsLog 'adding external log to main log ...'
	DebugExtLogMinorSeparator
	DebugAsLog "$(FormatAsLogFilename "$1")"

	while read -r a; do
		DebugAsLog "$a"
	done < "$1"

	DebugExtLogMinorSeparator
	debug=$debug_was_set

	}

DebugExtLogMinorSeparator()
	{

	DebugAsLog "$(DebugMinorSeparator)"

	}

DebugBulletSeparatorWithText()
	{

	# Inputs: (global)
	#	$r_debug_log_datawidth

	# Inputs:
	#   $1 = Text to center in separator line.

	local a=''
	[[ -n ${1:-} ]] && a=" ${1:-} "

	local b=$(((r_debug_log_datawidth-${#a})/2))
	local c=$((r_debug_log_datawidth-${#a}-b))

	eval printf '%0.s•' "{1..$b}"; printf '%s' "$a"; eval printf '%0.s•' "{1..$c}"; echo 	# `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugMinorSeparator()
	{

	# Inputs: (global)
	#	$r_debug_log_datawidth

	eval printf '%0.s-' "{1..$r_debug_log_datawidth}"		# `seq` is unavailable in QTS, so must resort to `eval` trickery instead.

	}

DebugAsLog()
	{

	[[ -n ${1:-} ]] || return

	DebugThis "(LL) $1"

	}

DebugThis()
	{

	# Inputs: (global)
	#	$debug

	[[ $debug = true ]] && Display "${1:-}"
	WriteAsDebug "${1:-}"

	}

WriteAsDebug()
	{

	WriteToLog dbug "${1:-}"

	}

WriteToLog()
	{

	# Inputs: (global)
	#	$r_service_log_pathfile

	# Inputs: (local)
	#   $1 = pass/fail
	#   $2 = message

	printf "%-4s: %s\n" "$(StripANSICodes "${1:-}")" "$(StripANSICodes "${2:-}")" >> "$r_service_log_pathfile"

	}

StripANSICodes()
	{

	# QTS 4.2.6 BusyBox `sed` doesn't fully support extended regexes, so this only works with a real `sed`.

	if [[ -e /opt/bin/sed && -L /opt/etc/passwd ]]; then	# Try to ensure Entware is active before using this utility.
		/opt/bin/sed -r 's/\x1b\[[0-9;]*m//g' <<< "${1:-}"
	else
		echo "${1:-}"		# Can't strip, so pass thru original message unaltered.
	fi

	}

Capitalise()
	{

	# Capitalise first character of $1

	echo "$(Uppercase ${1:0:1})${1:1}"

	}

Uppercase()
	{

	/bin/tr 'a-z' 'A-Z' <<< "$1"

	}

Lowercase()
	{

	/bin/tr 'A-Z' 'a-z' <<< "$1"

	}

ReWriteUIPorts()
	{

	# Write the current application UI ports into the QTS App Center configuration.

	# QTS App Center requires 'Web_Port' to always be non-zero.

	# 'Web_SSL_Port' behaviour:
	#		   < -2 = crashes current QTS session. Starts with non-responsive package icons in App Center.
	# missing or -2 = QTS will fallback from HTTPS to HTTP, with a warning to user.
	#			 -1 = launch QTS UI again (only if WebUI = '/'), else show "QNAP Error" page.
	#			  0 = "unable to connect".
	#			> 0 = works if logged-in to QTS UI via HTTPS.

	# If SSL is enabled, attempting to access with non-SSL via 'Web_Port' results in "connection was reset".

	# Inputs: (global)
	#	$get_daemon_port_cmd
	#	$r_qpkg_name
	#	$ui_port
	#	$ui_port_secure

	[[ $get_daemon_port_cmd != undefined ]] && return		# Don't need to rewrite QTS UI ports if this app has a daemon port, as UI ports are unused.

	DisplayWaitCommitToLog '> update QPKG icon with UI ports:'
	/sbin/setcfg $r_qpkg_name Web_Port "$ui_port" -f /etc/config/qpkg.conf

	if IsSSLEnabled; then
		/sbin/setcfg $r_qpkg_name Web_SSL_Port "$ui_port_secure" -f /etc/config/qpkg.conf
	else
		/sbin/setcfg $r_qpkg_name Web_SSL_Port '-2' -f /etc/config/qpkg.conf
	fi

	DisplayCommitToLog OK

	}

CheckPorts()
	{

	# Inputs: (global)
	#	$daemon_port
	#	$ui_listening_address
	#	$ui_port
	#	$ui_port_secure

	local a=''

	DisplayCommitToLog "- daemon listening address: '$ui_listening_address'"

	if [[ $daemon_port -ne 0 ]]; then
		DisplayCommitToLog "- daemon port: '$daemon_port'"

		if IsPortResponds $daemon_port; then
			a="daemon port '$daemon_port'"
		fi
	else
		DisplayWaitCommitToLog '- HTTPS port enabled:'

		if IsSSLEnabled; then
			DisplayCommitToLog true
			DisplayCommitToLog "- HTTPS port: '$ui_port_secure'"

			if IsPortSecureResponds $ui_port_secure; then
				a="HTTPS port '$ui_port_secure'"
			fi
		else
			DisplayCommitToLog false
		fi

		DisplayCommitToLog "- HTTP port: '$ui_port'"

		if IsPortResponds $ui_port; then
			[[ -n $a ]] && a+=' and '
			a+="HTTP port '$ui_port'"
		fi
	fi

	if [[ -z $a ]]; then
		DisplayErrCommitAllLogs 'no response on configured port(s)'

		SetError; return 1
	else
		ReWriteUIPorts
		return 0
	fi

	}

GetPythonVer()
	{

	local a=''

	a=$(GetThisBinPath ${1:-python} &>/dev/null && ${1:-python} -V 2>&1 | /bin/sed 's|^Python ||;s|\.||g')

	[[ -n $a ]] && echo "${a:0:3}"

	}

GetThisBinPath()
	{

	[[ -n ${1:?null} ]] && command -v "$1" 2>&1

	}

RenameSharedObjectFile()
	{

	# Must check 3 possible module locations.

	[[ -n ${1:-} ]] || return

	if [[ -e $(GetModulePath)/$(GetOriginalModuleSOFilename "_$1") ]]; then
		mv "$(GetModulePath)/$(GetOriginalModuleSOFilename "_$1")" "$(GetModulePath)/$(GetFixedModuleSOFilename "_$1")"
		DisplayCommitToLog "= renamed module: _$1"
	fi

	if [[ -e $(GetModulePath)/$1/$(GetOriginalModuleSOFilename "$1") ]]; then
		mv "$(GetModulePath)/$1/$(GetOriginalModuleSOFilename "$1")" "$(GetModulePath)/$1/$(GetFixedModuleSOFilename "$1")"
		DisplayCommitToLog "= renamed module: $1/$1"
	fi

	if [[ -e $(GetModulePath)/$(GetOriginalModuleSOFilename "$1") ]]; then
		mv "$(GetModulePath)/$(GetOriginalModuleSOFilename "$1")" "$(GetModulePath)/$(GetFixedModuleSOFilename "$1")"
		DisplayCommitToLog "= renamed module: $1"
	fi

	return 0

	}

GetOriginalModuleSOFilename()
	{

	# Inputs: (local)
	#	$1 = Python module name

	# Inputs: (global)
	#	$pyver

	# Outputs: (local)
	#	stdout = filename

	# Outputs: (global)
	#	$pyver

	[[ -z $pyver ]] && pyver=$(GetPythonVer)
	[[ -n ${1:-} ]] && echo "$1.cpython-$pyver-$(/bin/uname -m)-linux-gnu.so"

	}

GetFixedModuleSOFilename()
	{

	# Inputs: (local)
	#	$1 = Python module name

	# Inputs: (global)
	#	$pyver

	# Outputs: (local)
	#	stdout = filename

	# Outputs: (global)
	#	$pyver

	[[ -z $pyver ]] && pyver=$(GetPythonVer)
	[[ -n ${1:-} ]] && echo "$1.cpython-$pyver.so"

	}

GetModulePath()
	{

	# Inputs: (local)
	#	$1 = Python module name

	# Inputs: (global)
	#	$pyver
	#	$venv_path

	# Outputs: (local)
	#	stdout = path

	# Outputs: (global)
	#	$pyver

	[[ -z $pyver ]] && pyver=$(GetPythonVer)
	echo "$venv_path/lib/python${pyver:0:1}.${pyver:1:2}/site-packages"

	}

parse_yaml()
	{

	# a nice bit of coding! https://stackoverflow.com/a/21189044

	# Inputs: (local)
	#   $1 = filename to parse.
	#	$2 (optional) = key prefix.

	# Outputs:
	#   stdout = parsed YAML

	local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')

	/bin/sed -ne "s|^\($s\):|\1|" \
		-e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
		-e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
		/bin/awk -F$fs '{
			indent = length($1)/2;
			vname[indent] = $2;
			for (i in vname) {if (i > indent) {delete vname[i]}}
				if (length($3) > 0) {
				vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
				printf("%s%s%s=\"%s\"\n", "'${2:-}'",vn, $2, $3);
				}
			}'
	}

IsQNAP()
	{

	# Outputs: (local)
	#   $? = 0 : this is a QNAP NAS
	#   $? = 1 : not a QNAP

	if [[ ! -e /etc/init.d/functions ]]; then
		Display 'QTS functions missing (is this a QNAP NAS?)'

		SetError; return 1
	fi

	return 0

	}

IsQPKGInstalled()
	{

	# Inputs: (local)
	#   $1 (optional) = package name to check. If unspecified, default is $r_qpkg_name

	# Inputs: (global)
	#   $r_qpkg_name

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	/bin/grep -q "^\[${1:-$r_qpkg_name}\]" /etc/config/qpkg.conf

	}

IsNotQPKGInstalled()
	{

	# Inputs: (local)
	#   $1 (optional) = package name to check. If unspecified, default is $r_qpkg_name

	# Inputs: (global)
	#   $r_qpkg_name

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	! IsQPKGInstalled "${1:-$r_qpkg_name}"

	}

IsQPKGActive()
	{

	IsDaemon && IsDaemonActive

	}

IsNotQPKGActive()
	{

	! IsNotQPKGActive

	}

IsQPKGEnabled()
	{

	# Inputs: (local)
	#   $1 (optional) = package name to check. If unspecified, default is $r_qpkg_name

	# Inputs: (global)
	#   $r_qpkg_name

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $(Lowercase "$(/sbin/getcfg ${1:-$r_qpkg_name} Enable -d false -f /etc/config/qpkg.conf)") = true ]]

	}

IsNotQPKGEnabled()
	{

	# Inputs: (local)
	#   $1 (optional) = package name to check. If unspecified, default is $r_qpkg_name

	# Inputs: (global)
	#   $r_qpkg_name

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	! IsQPKGEnabled "${1:-$r_qpkg_name}"

	}

IsSupportBackup()
	{

	# Inputs: (global)
	#   $qpkg_backup_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $qpkg_backup_pathfile != undefined ]]

	}

IsNotSupportBackup()
	{

	! IsSupportBackup

	}

IsSupportReset()
	{

	# Inputs: (global)
	#   $qpkg_ini_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $qpkg_ini_pathfile != undefined ]]

	}

IsNotSupportReset()
	{

	! IsSupportReset

	}

IsSupportActions()
	{

	# Inputs: (global)
	#   $r_service_action_pathfile
	#   $r_service_result_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ -e $r_service_action_pathfile || -e $r_service_result_pathfile ]]

	}

IsNotSupportActions()
	{

	! IsSupportActions

	}

IsSupportGetAppVersion()
	{

	# Inputs: (global)
	#   $get_app_version_cmd
	#   $app_version_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $get_app_version_cmd != undefined && $app_version_pathfile != undefined ]]

	}

IsNotSupportGetAppVersion()
	{

	! IsSupportGetAppVersion

	}

IsVirtualPythonEnv()
	{

	# Inputs: (global)
	#   $venv_path

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $venv_path != undefined ]]

	}

IsNotVirtualPythonEnv()
	{

	! IsVirtualPythonEnv

	}

IsGitApp()
	{

	# Is this application pulled from an online source with `git`?

	# Inputs: (global)
	#   $source_git_url
	#   $source_git_branch
	#   $qpkg_repo_path

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $source_git_url != undefined && $source_git_branch != undefined && $qpkg_repo_path != undefined ]]

	}

IsNotGitApp()
	{

	! IsGitApp

	}

IsUsePipCache()
	{

	# Inputs: (global)
	#   $pip_cache_path

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $pip_cache_path != undefined ]]

	}

IsNotUsePipCache()
	{

	! IsUsePipCache

	}

IsOnlineReleasePackage()
	{

	# Inputs: (global)
	#   $remote_url

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $remote_url != undefined ]]

	}

IsNotOnlineReleasePackage()
	{

	! IsOnlineReleasePackage

	}

IsReleaseAnArchive()
	{

	# Inputs: (global)
	#   $package_is_exec

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $package_is_exec != undefined && $package_is_exec = false ]]

	}

IsNotReleaseAnArchive()
	{

	! IsReleaseAnArchive

	}

IsSupportAutoUpdate()
	{

	# Inputs: (global)
	#   $can_restart_to_update

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $can_restart_to_update = true ]]

	}

IsNotSupportAutoUpdate()
	{

	! IsSupportAutoUpdate

	}

IsSourcedOnline()
	{

	IsGitApp || IsUsePipCache || IsOnlineReleasePackage

	}

IsNotSourcedOnline()
	{

	! IsSourcedOnline

	}

IsUseTemp()
	{

	# Inputs: (global)
	#   $r_qpkg_temp_path

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $r_qpkg_temp_path != undefined ]]

	}

IsNotUseTemp()
	{

	! IsUseTemp

	}

IsSSLEnabled()
	{

	# Inputs: (global)
	#   $get_ui_port_secure_enabled_test_cmd

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	eval "$get_ui_port_secure_enabled_test_cmd"

	}

IsNotSSLEnabled()
	{

	! IsSSLEnabled

	}

IsDaemon()
	{

	# Inputs: (global)
	#   $daemon_exec_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $daemon_exec_pathfile != undefined ]]

	}

IsNotDaemon()
	{

	! IsDaemon

	}

IsDaemonCheck()
	{

	# Inputs: (global)
	#   $daemon_check_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $daemon_check_pathfile != undefined ]]

	}

IsNotDaemonCheck()
	{

	! IsDaemonCheck

	}

IsDaemonActive()
	{

	# Inputs: (global)
	#   $daemon_pid_pathfile

	# Outputs: (local)
	# 	$? = 0 : daemon is in memory
	# 	$? = 1 : daemon is not in memory

	if IsDaemonProcessActive; then
		DisplayCommitToLog "- daemon PID: '$(<"$daemon_pid_pathfile")'"
		return 0
	fi

	DisplayCommitToLog '- daemon PID: none'
	return 1

	}

IsNotDaemonActive()
	{

	! IsDaemonActive

	}

IsDaemonProcessActive()
	{

	# Inputs: (global)
	#   $daemon_check_pathfile
	#   $daemon_exec_pathfile
	#   $daemon_pid_pathfile

	# Outputs: (local)
	#   $? = 0 : $daemon_exec_pathfile is in memory
	#   $? = 1 : $daemon_exec_pathfile is not in memory

	if [[ -e $daemon_pid_pathfile && -d /proc/"$(<$daemon_pid_pathfile)" ]]; then
		if IsDaemonCheck; then
			[[ $(/usr/bin/readlink /proc/"$(<$daemon_pid_pathfile)"/exe) = "$daemon_check_pathfile" ]]
		else
			[[ $(</proc/"$(<$daemon_pid_pathfile)"/cmdline) =~ $daemon_exec_pathfile ]]
		fi
	else
		false
	fi

	}

IsSysFilePresent()
	{

	# Inputs: (local)
	#   $1 = pathfilename to check.

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	if [[ -z ${1:?pathfilename null} ]]; then
		SetError; return 1
	fi

	if [[ ! -e $1 ]]; then
		Display "A required NAS system file is missing: '$1'"

		SetError; return 1
	fi

	return 0

	}

IsNotSysFilePresent()
	{

	# Inputs: (local)
	#   $1 = pathfilename to check.

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	! IsSysFilePresent "${1:?pathfilename null}"

	}

IsPortAvailable()
	{

	# Inputs: (local)
	#   $1 = port to check.

	# Outputs: (local)
	#   $? = 0 : available.
	#   $? = 1 : already used.

	local port=${1//[!0-9]/}			# Strip all non-numerals.
	[[ -n $port && $port -gt 0 ]] || return 0

	/usr/sbin/lsof -i :"$port" -sTCP:LISTEN >/dev/null 2>&1 && return 1

	return 0

	}

IsNotPortAvailable()
	{

	# Inputs: (local)
	#   $1 = port to check.

	# Outputs: (local)
	#   $? = 1 : port available.
	#   $? = 0 : already used.

	! IsPortAvailable "${1:-0}"

	}

IsPortResponds()
	{

	# Inputs: (local)
	#   $1 = port to check.

	# Inputs: (global)
	#   $watch_port_check_seconds

	# Outputs: (local)
	#   $? = 0 : response received.
	#   $? = 1 : not OK.

	local -i a=${1//[!0-9]/}			# Strip all non-numerals.
	local -i b=$(CalcAdaptiveSeconds "$watch_port_check_seconds")
	local -i c=0

	if [[ -z $a ]]; then
		Display 'empty port: not testing for response'
		return 1
	elif [[ $a -eq 0 ]]; then
		Display "port '0': not testing for response"
		return 1
	fi

	DisplayWaitCommitToLog "> test for port '$a' response (no-more than $b second$(Pluralise "$b")):"

	while true; do
		if ! IsDaemonProcessActive; then
			DisplayCommitToLog 'process not active'
			break
		fi

		/sbin/curl --silent --fail --max-time 1 http://localhost:"$a" &>/dev/null

		case $? in
			0|22|52)	# Accept these exitcodes as evidence of valid responses.
				Display OK
				CommitToLog "responded in $c second$(Pluralise "$c")"
				return 0
				;;
			28)			# Timed-out.
				: 			# do nothing
				;;
			7)			# This code is returned immediately,
				/bin/sleep 1		# ... so let's wait here a bit.
				;;
			*)
				: 			# do nothing
		esac

		((c++))
		DisplayWait "$c,"

		if [[ $c -ge $b ]]; then
			DisplayCommitToLog failed
			CommitErrToSysLog "port '$a' failed to respond after $c second$(Pluralise "$c")!"
			break
		fi
	done

	return 1

	}

IsPortSecureResponds()
	{

	# Inputs: (local)
	#   $1 = secure port to check.

	# Inputs: (global)
	#   $watch_port_check_seconds

	# Outputs: (local)
	#   $? = 0 : response received.
	#   $? = 1 : not OK or secure port unspecified.

	local -i a=${1//[!0-9]/}			# Strip all non-numerals.
	local -i b=$(CalcAdaptiveSeconds "$watch_port_check_seconds")
	local -i c=0

	if [[ -z $a ]]; then
		Display 'empty port: not testing for response'
		return 1
	elif [[ $a -eq 0 ]]; then
		Display "port '0': not testing for response"
		return 1
	fi

	DisplayWaitCommitToLog "> test for secure port '$a' response (no-more than $b second$(Pluralise "$b")):"

	while true; do
		if ! IsDaemonProcessActive; then
			DisplayCommitToLog 'process not active'
			break
		fi

		/sbin/curl --silent --insecure --fail --max-time 1 https://localhost:"$a" &>/dev/null

		case $? in
			0|22|52)	# Accept these exitcodes as evidence of valid responses.
				Display OK
				CommitToLog "port responded after $c second$(Pluralise "$c")"
				return 0
				;;
			35)
				DisplayCommitToLog 'TLS inactive'
				break
				;;
			28)			# Timed-out.
				: 			# do nothing
				;;
			7)			# This code is returned immediately,
				/bin/sleep 1		# ... so let's wait here a bit.
				;;
			*)
				: 			# do nothing
		esac

		((c++))
		DisplayWait "$c,"

		if [[ $c -ge $b ]]; then
			DisplayCommitToLog failed
			CommitErrToSysLog "secure port '$a' failed to respond after $c second$(Pluralise "$c")!"
			break
		fi
	done

	return 1

	}

IsConfigFound()
	{

	# Is there an application configuration file?

	# Inputs: (global)
	#   $qpkg_ini_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $qpkg_ini_pathfile != undefined && -e $qpkg_ini_pathfile ]]

	}

IsNotConfigFound()
	{

	! IsConfigFound

	}

IsDefaultConfigFound()
	{

	# Is there a default application configuration file?

	# Inputs: (global)
	#   $qpkg_ini_default_pathfile

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $qpkg_ini_default_pathfile != undefined && -e $qpkg_ini_default_pathfile ]]

	}

IsNotDefaultConfigFound()
	{

	! IsDefaultConfigFound

	}

IsVirtualPythonEnvExist()
	{

	# Is there a virtual Python environment?

	# Inputs: (global)
	#   $venv_path

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ -e $venv_path/bin/activate ]]

	}

IsNotVirtualPythonEnvExist()
	{

	! IsVirtualPythonEnvExist

	}

OSIsSupportSecureDownload()
	{

	# Inputs: (global)
	#   $r_nas_firmware_version

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ ${r_nas_firmware_version//.} -ge 500 ]]

	}

IsSiteUp()
	{

	# Test if remote site is reachable.

	# Inputs: (local)
	#   $1 = URL to query.

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ -n $1 && $1 != undefined ]] || return

	local a=$(cut -d'/' -f3 <<< "$1" | cut -d':' -f1)

	[[ -n $a && $a != undefined ]] || return

	local -i n=0

	for ((n=0; n<20; n++)); do
		/bin/ping -c 1 -w 1 "$a" && return 0
		/bin/sleep 5
	done

	return 1

	} &>/dev/null

RequestLatestReleaseFilename()
	{

	# Request latest release filename from remote site.

	# NOTE: *arr servers don't permit HEAD request, so must issue a GET and follow 304 URL to get final filename.
	# Issuing a GET will also attempt to download the target file, so rate-limit the download speed to 1KB/s as the file isn't actually wanted anyway, and let file download time-out.

	# Inputs: (local)
	#   $1 = URL to check.
	#   $2 (optional) = arch to match.

	# Inputs: (global)
	#	$curl_insecure_arg
	#	$get_remote_filename_timeout_seconds

	# Outputs: (local)
	#   stdout = filename.

	[[ -n ${1:-} && ${1:-} != undefined ]] || return

	local a="$curl_insecure_arg --silent --max-time $get_remote_filename_timeout_seconds --limit-rate 1K --location --dump-header -"	# https://stackoverflow.com/a/26644485
	local b=$(/sbin/curl${a} "${1/https/http}" | /bin/grep -v 'Location:' | /bin/grep filename | cut -d';' -f2 | cut -d'=' -f2 | /bin/sed -e 's|\r||g')
	[[ -n ${2:-} && ${2:-} != undefined ]] && b=$(/bin/grep "$2" <<< "$b")

	printf '%s' "$b"

	} 2>/dev/null

RequestLatestReleaseURL()
	{

	# Request latest release URL from remote site.

	# Inputs: (local)
	#   $1 = URL to check.
	#   $2 (optional) = arch to match.

	# Inputs: (global)
	#	$curl_insecure_arg
	#	$get_remote_filename_timeout_seconds

	# Outputs: (local)
	#   stdout = URL.

	[[ -n ${1:-} && ${1:-} != undefined ]] || return

	local a="$curl_insecure_arg --silent --max-time $get_remote_filename_timeout_seconds --location"	# https://gist.github.com/steinwaywhw/a4cd19cda655b8249d908261a62687f8
	local b=$(/sbin/curl${a} "$1" | /bin/grep browser_download_url | cut -d\" -f4)
	[[ -n ${2:-} && ${2:-} != undefined ]] && b=$(/bin/grep "$2" <<< "$b")

	printf '%s' "$b"

	} 2>/dev/null

DownloadReleasePackage()
	{

	# Request specific release filename from remote site.

	# Inputs: (local)
	#   $1 = URL of the source release package.
	#	$2 = pathfilename to save the release package to.

	# Inputs: (global)
	#	$curl_insecure_arg
	#	$debug

	[[ -n ${1:-} && ${1:-} != undefined ]] || return
	[[ -n ${2:-} && ${2:-} != undefined ]] || return

	local a=''
	local b=$curl_insecure_arg
	local c=$2

	[[ $debug = false ]] && b+=' --silent'

	if [[ -e $c ]]; then
		a='refresh existing release package (only-if-newer)'
		b+=" --time-cond $c"
	else
		a='download latest release package'
	fi

	b+=" --show-error --max-time 300 --location --output $c"

	DisplayRunAndLog "$a" "/sbin/curl${b} '$1'" log:failure-only

	}

ExtractReleasePackage()
	{

	# Inputs: (local)
	#	$1 = pathfilename of the release package to process.
	#   $2 (optional) = release package name ref pathfilename.

	# Inputs: (global)
	#	$compare_release_filename
	#	$debug
	#	$qpkg_repo_path

	[[ -n ${1:-} && ${1:-} != undefined ]] || return

	local release_package_name_ref_pathfilename=''
	local release_package_pathfile=$1
	local tar_opts=''
	local tar_verbose=''
	local unzip_opts=''
	local unzip_verbose=''

	[[ -n ${2:-} && ${2:-} != undefined ]] && release_package_name_ref_pathfilename=$2

	if [[ $debug = true ]]; then
		tar_verbose=' --verbose'
# 			unzip_verbose=' -v'			# Don't enable this, seems to prevent file extraction.
	fi

	if [[ -e $release_package_pathfile ]]; then
		tar_opts="$tar_verbose --extract --gzip --file=$release_package_pathfile --directory=$qpkg_repo_path"
		unzip_opts="$unzip_verbose -o $release_package_pathfile -d $qpkg_repo_path"

		# Try as '.zip' first, then '.tar.gz'
		DisplayRunAndLog 'extract from release package' "/usr/bin/unzip${unzip_opts} 2>/dev/null || /bin/tar${tar_opts}" log:failure-only

		if [[ $compare_release_filename = true && -n $release_package_name_ref_pathfilename ]]; then
			if [[ ! -e $release_package_name_ref_pathfilename ]]; then
				DisplayRunAndLog 'create release package name reference' "/bin/touch $release_package_name_ref_pathfilename" log:failure-only
			fi
		fi
	fi

	}

MakeExecReleasePackage()
	{

	# Inputs: (local)
	#	$1 = pathfilename of the release package to process.
	#   $2 (optional) = release package name ref pathfilename.

	# Inputs: (global)
	#	$compare_release_filename
	#	$daemon_exec_pathfile
	#	$qpkg_repo_path

	[[ -n ${1:-} && ${1:-} != undefined ]] || return

	local release_package_name_ref_pathfilename=''
	local release_package_pathfile=$1

	[[ -n ${2:-} && ${2:-} != undefined ]] && release_package_name_ref_pathfilename=$2

	if [[ -e $release_package_pathfile ]]; then
		DisplayRunAndLog 'copy release package' "cp -f $release_package_pathfile $daemon_exec_pathfile" log:failure-only
		[[ ! -x $daemon_exec_pathfile ]] && DisplayRunAndLog 'make release package executable' "chmod +x $daemon_exec_pathfile" log:failure-only

		if [[ $compare_release_filename = true && -n $release_package_name_ref_pathfilename ]]; then
			if [[ ! -e $release_package_name_ref_pathfilename ]]; then
				DisplayRunAndLog 'create release package name reference' "/bin/touch $release_package_name_ref_pathfilename" log:failure-only
			fi
		fi
	fi

	}

ResetServiceAction()
	{

	SetServiceAction reset-action
	SetServiceResultAsOK

	}

SetServiceAction()
	{

	service_action=${1:-none}
	CommitServiceAction
	SetServiceResultAsInProgress
	DisplayAndCommitActionToLog

	}

SetServiceResultAsOK()
	{

	service_result=ok
	CommitServiceResult
	DisplayAndCommitResultToLog

	}

SetServiceResultAsFailed()
	{

	service_result=failed
	CommitServiceResult
	DisplayAndCommitResultToLog

	}

SetServiceResultAsAborted()
	{

	# Selected action received a SIGINT while executing.

	service_result=aborted
	CommitServiceResult
	DisplayAndCommitResultToLog

	}

SetServiceResultAsInProgress()
	{

	# Selected action is in-progress and hasn't generated a result yet.

	service_result=in-progress
	CommitServiceResult

	}

SetServiceResultAsUnsupported()
	{

	# Selected action isn't supported by this QPKG.

	service_result=unsupported
	CommitServiceResult

	}

CommitServiceAction()
	{

	if IsNotStatus && IsNotLog && IsNotNone; then
		[[ $r_service_action_pathfile != undefined ]] && echo "$service_action" > "$r_service_action_pathfile"
	fi

	}

CommitServiceResult()
	{

	if IsNotStatus && IsNotLog && IsNotNone; then
		[[ $r_service_result_pathfile != undefined ]] && echo "$service_result" > "$r_service_result_pathfile"
	fi

	}

SetQPKGWasActive()
	{

	_qpkg_was_active=true

	}

UnsetQPKGWasActive()
	{

	_qpkg_was_active=false

	}

QPKGWasActive()
	{

	[[ ${_qpkg_was_active:=false} = true ]]

	}

QPKGWasNotActive()
	{

	[[ ${_qpkg_was_active:=false} = false ]]

	}

SetStatusGet()
	{

	_get_status_flag=true

	}

UnsetStatusGet()
	{

	_get_status_flag=false

	}

IsStatus()
	{

	[[ ${_get_status_flag:=false} = true ]]

	}

IsNotStatus()
	{

	! IsStatus

	}

SetError()
	{

	IsError && return
	_error_flag=true

	}

UnsetError()
	{

	IsNotError && return
	_error_flag=false

	}

IsError()
	{

	[[ ${_error_flag:=false} = true ]]

	}

IsNotError()
	{

	! IsError

	}

IsReinstall()
	{

	# `REINSTALL_QPKG=true` is set in sherpa management script when action 'reinstall' is run.

	[[ ${REINSTALL_QPKG:=false} = true ]]

	}

IsUpgrade()
	{

	# `UPGRADE_QPKG=true` is set in sherpa management script when action 'upgrade' is run.

	[[ ${UPGRADE_QPKG:=false} = true ]]

	}

IsStart()
	{

	[[ $service_action = start ]]

	}

IsNotStart()
	{

	! IsStart

	}

IsStop()
	{

	[[ $service_action = stop ]]

	}

IsNotStop()
	{

	! IsStop

	}

IsRestart()
	{

	[[ $service_action = restart ]]

	}

IsNotRestart()
	{

	! IsRestart

	}

IsLog()
	{

	[[ $service_action = log ]]

	}

IsNotLog()
	{

	! IsLog

	}

IsNone()
	{

	[[ $service_action = none ]]

	}

IsNotNone()
	{

	! IsNone

	}

IsClean()
	{

	[[ $service_action = clean ]]

	}

IsNotClean()
	{

	! IsClean

	}

IsBackup()
	{

	[[ $service_action = backup ]]

	}

IsNotBackup()
	{

	! IsBackup

	}

IsRestore()
	{

	[[ $service_action = restore ]]

	}

IsNotRestore()
	{

	! IsRestore

	}

IsReset()
	{

	[[ $service_action = reset ]]

	}

IsNotReset()
	{

	! IsReset

	}

IsUnsupported()
	{

	[[ $service_action = unsupported ]]

	}

IsServiceResultInProgress()
	{

	[[ $service_result = in-progress ]]

	}

IsPathEmpty()
	{

	# Inputs: (local)
	#   $1 = directory to check if empty.

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false or $1 does not exist.

	local a=${1:-}

	[[ -n $a && -d $a ]] || return

	rmdir "$a" &>/dev/null && mkdir "$a"

	}

IsNotPathEmpty()
	{

	! IsPathEmpty "${1:-}"

	}

ShowAsError()
	{

	# fatal error

	Display "$(TextBrightRed derp): $(Capitalise "${1:-}")"

	} >&2

DisplayCommitToLog()
	{

	Display "${1:-}"
	CommitToLog "${1:-}"

	}

DisplayWaitCommitToLog()
	{

	DisplayWait "${1:-}"
	CommitToLogWait "${1:-}"

	}

DisplayWarnCommitAllLogs()
	{

	DisplayCommitToLog "${1:-}"
	CommitWarnToSysLog "${1:-}"

	}

DisplayErrCommitAllLogs()
	{

	DisplayCommitToLog "${1:-}"
	CommitErrToSysLog "${1:-}"

	}

FormatAsLogFilename()
	{

	echo "= log file: '${1:-}'"

	}

FormatAsCommand()
	{

	Display "command: '${1:-}'"

	}

FormatAsStdout()
	{

	Display "output: \"${1:-}\""

	}

FormatAsResult()
	{

	Display "result: $(FormatAsExitcode "${1:-}")"

	}

FormatAsResultAndStdout()
	{

	if [[ ${1:-0} -eq 0 ]]; then
		echo "= result_code: $(FormatAsExitcode "$1")"
	else
		echo "= result_code: $(FormatAsExitcode "$1")"
	fi

	DebugBulletSeparatorWithText 'stdout & stderr begins below'
	echo "${2:-}"
	DebugBulletSeparatorWithText 'stdout & stderr is complete'

	}

FormatAsFuncMessages()
	{

	echo "= ${FUNCNAME[1]}()"
	FormatAsCommand "${1:?command null}"
	FormatAsStdout "${2:-}"

	}

FormatAsExitcode()
	{

	echo "[${1:-}]"

	}

FormatAsPackageName()
	{

	echo "'${1:-}'"

	}

DisplayAsHelp()
	{

	printf '  %-22s  - %s\n' "${1:-}" "${2:-}."

	}

Display()
	{

	echo "${1:-}"

	}

DisplayWait()
	{

	echo -n "${1:-} "

	}

DisplayAndCommitActionToLog()
	{

	# Inputs: (global)
	#   $r_qpkg_version
	#   $service_action
	#   $r_service_library_version
	#   $r_service_script_version

	# Outputs: (global)
	#   $starttime

	[[ $service_action = unspecified ]] && return

	starttime=$(/bin/date +%s%N)
	local msg="> source: $(/usr/bin/basename "$0"), action: $service_action, time: $(date), load: $(GetSysLoad1MinAverage)"
	msg="$(/bin/tr -s ' ' <<< "$msg") "
	local a=DisplayCommitToLog

	if IsNotStatus && IsNotLog && IsNotNone; then
		IsUnsupported && a=CommitToLog
		CommitToLog '•'

		$a "$(TextInverse "$msg")"
		$a "- package: $r_qpkg_version, service: $r_service_script_version, library: $r_service_library_version"
	fi

	}

DisplayAndCommitResultToLog()
	{

	# Inputs: (global)
	#   $service_action
	#   $service_result
	#   $starttime

	[[ $service_action = unspecified ]] && return

	local msg="= source: $(/usr/bin/basename "$0"), action: $service_action, time: $(date), result: $service_result, elapsed: $(FormatAsDuration "$(CalcMilliDifference "$starttime" "$(/bin/date +%s%N)")"), load: $(GetSysLoad1MinAverage)"
	msg="$(/bin/tr -s ' ' <<< "$msg") "
	local a=DisplayCommitToLog

	if IsNotStatus && IsNotLog && IsNotNone; then
		IsUnsupported && a=CommitToLog

		case $service_result in
			ok)
				$a "$(TextBlackOnGreen "$msg")"
				;;
			failed)
				$a "$(TextBlackOnRed "$msg")"
				;;
			*)
				$a "$(TextBlackOnYellow "$msg")"
		esac
	fi

	}

CommitInfoToSysLog()
	{

	CommitSysLog "${1:-}" 4

	}

CommitWarnToSysLog()
	{

	CommitSysLog "${1:-} Please check the service log for more information." 2

	}

CommitErrToSysLog()
	{

	CommitSysLog "${1:-}" 1

	}

CommitToLog()
	{

	if IsNotStatus && IsNotLog && IsNotNone; then
		[[ ${1:-} = '•' && ! -s "$r_service_log_pathfile" ]] || echo -e "${1:-}" >> "$r_service_log_pathfile"
	fi

	}

CommitToLogWait()
	{

	if IsNotStatus && IsNotLog && IsNotNone; then
		printf '%s' "${1:-} " >> "$r_service_log_pathfile"
	fi

	}

CommitSysLog()
	{

	# Inputs: (global)
	#   $r_qpkg_name

	# Inputs: (local)
	#   $1 = message to append to QTS system log
	#   $2 = event type:
	#	 	1 : Error
	#	 	2 : Warning
	#		4 : Information

	if IsNotStatus && IsNotLog && IsNotNone; then
		if [[ -z ${1:-} || -z ${2:-} ]]; then
			SetError; return 1
		fi

		/sbin/write_log "[$r_qpkg_name] $1" "$2"
	fi

	}

TextBrightWhite()
	{

	printf '\033[1;97m%s\033[0m' "${1:-}"

	} 2>/dev/null

TextBrightRed()
	{

	printf '\033[1;31m%s\033[0m' "${1:-}"

	} 2>/dev/null

TextBlackOnGreen()
	{

	printf '\033[30;42m%s\033[0m' "${1:-}"

	} 2>/dev/null

TextBlackOnRed()
	{

	printf '\033[30;41m%s\033[0m' "${1:-}"

	} 2>/dev/null

TextBlackOnYellow()
	{

	printf '\033[30;43m%s\033[0m' "${1:-}"

	} 2>/dev/null

TextInverse()
	{

	printf '\033[7m%s\033[0m' "${1:-}"

	} 2>/dev/null

Pluralise()
	{

	[[ ${1:-0} -ne 1 ]] && echo s

	}

CalcMilliDifference()
	{

	# Inputs: (local)
	#	$1 = starttime in epoch nanoseconds
	#	$2 = endtime in epoch nanoseconds

	# Outputs: (local)
	#	stdout = difference in milliseconds

	echo "$(((${2:-1}-${1:-0})/1000000))"

	}

FormatAsThous()
	{

	# Format as thousands.

	# A string-based thousands-group formatter totally unreliant on locale.
	# Why? Because builtin `printf` in 32b ARM QTS versions doesn't follow locale. ¯\_(ツ)_/¯

	# Inputs: (local)
	# 	$1 = Integer value.

	# Outputs: (local)
	#	stdout = formatted number string

	local rightside_group=''
	local foutput=''
	local remainder=$(/bin/sed 's/[^0-9]*//g' <<< "${1:-}")	# Strip all non-numerals.

	while [[ ${#remainder} -gt 0 ]]; do
		rightside_group=${remainder:${#remainder}<3?0:-3}	# A nifty trick found here: https://stackoverflow.com/a/19858692

		if [[ -z $foutput ]]; then
			foutput=$rightside_group
		else
			foutput=$rightside_group,$foutput
		fi

		if [[ ${#rightside_group} -eq 3 ]]; then
			remainder=${remainder%???}						# Trim rightside 3 characters.
		else
			break
		fi
	done

	printf '%s' "$foutput"

	return 0

	}

FormatAsDuration()
	{

	# Inputs: (local)
	#	$1 = Duration in milliseconds.

	if [[ ${1:-0} -lt 10000 ]]; then
		printf '%s' "$(FormatAsThous "${1:-0}")ms"
	else
		FormatSecsToHoursMinutesSecs "$(((${1:-0}+500)/1000))"		# Add 0.5s to improve apparent rounding accuracy.
	fi

	}

FormatSecsToHoursMinutesSecs()
	{

	# http://stackoverflow.com/questions/12199631/convert-seconds-to-hours-minutes-seconds

	# Inputs: (local)
	#	$1 = a time in seconds to convert to `HHh:MMm:SSs`

	# Outputs: (local)
	#	stdout = formatted time string

	((h=${1:-0}/3600))
	((m=(${1:-0}%3600)/60))
	((s=${1:-0}%60))

	printf '%01dh:%02dm:%02ds\n' "$h" "$m" "$s"

	} 2>/dev/null

IsAutoUpdateMissing()
	{

	# Inputs: (global)
	#	$r_qpkg_name

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	[[ $(/sbin/getcfg $r_qpkg_name Auto_Update -f /etc/config/qpkg.conf) = '' ]]

	}

IsAutoUpdate()
	{

	# Inputs: (global)
	#	$r_qpkg_name

	# Outputs: (local)
	#   $? = 0 : true
	#   $? = 1 : false

	IsSupportAutoUpdate && [[ $(Lowercase "$(/sbin/getcfg $r_qpkg_name Auto_Update -f /etc/config/qpkg.conf)") = true ]]

	}

IsNotAutoUpdate()
	{

	! IsAutoUpdate

	}

EnableAutoUpdate()
	{

	StoreAutoUpdateSelection true

	}

DisableAutoUpdate()
	{

	StoreAutoUpdateSelection false

	}

StoreAutoUpdateSelection()
	{

	# Inputs: (local)
	#	$1 = 'true', 'false'

	# Inputs: (global)
	#	$r_qpkg_name

	/sbin/setcfg $r_qpkg_name Auto_Update "$(Uppercase "$1")" -f /etc/config/qpkg.conf
	DisplayCommitToLog "- application auto-update: $1"

	}

GetPathGitBranch()
	{

	# Inputs: (local)
	#	$1 = path to git repo

	# Outputs: (local)
	#   stdout = branch name

	[[ -n $1 ]] || return

	/opt/bin/git -C "$1" branch | /bin/grep '^\*' | /bin/sed 's|^\* ||'

	} 2>/dev/null

IsSU()
	{

	# Running as superuser?

	if [[ $EUID -ne 0 ]]; then
		if [[ -e /usr/bin/sudo ]]; then
			ShowAsError 'this utility must be run with superuser privileges. Try again as:'
			Display "${r_chars_sudo_prompt}$0 $r_user_args_raw" >&2
		else
			ShowAsError "this utility must be run as the 'admin' user. Please login via SSH as 'admin' and try again"
		fi

		return 1
	fi

	return 0

	}

ShowUnsupportedAction()
	{

	ShowAsError "specified action '$1' is unsupported by this service-script."
	SetError
	CommitToLog "- specified action '$1' is unsupported."
	Display
	ShowHelp

	}

CalcAdaptiveSeconds()
	{

	# Inputs: (local)
	# 	$1 = Integer of base seconds (to suit 1m load average of 1.0 on a single-core CPU).

	# Outputs: (local)
	#   stdout = Integer of adapted seconds based-on present 1 minute load average. Maximum of 1800.

	local a=$(GetSysLoad1MinAverage); a=${a/./}		# Convert to hundreds.
	local b=$(($(GetCPUCores)*100))					# Match conversion amount for $a.
	local c=$((10#$a/10#$b))
	local d=$((10#${1:-1}))

	[[ $((10#$c)) -gt 1 ]] && d=$((c*d))
	[[ $((10#$d)) -gt 1800 ]] && d=1800

	printf '%s' "$d"

	}

GetSysLoad1MinAverage()
	{

	/usr/bin/uptime | /bin/sed 's|.*load average: ||' | /bin/awk -F', ' '{print $1}'

	}

GetCPUCores()
	{

	local a=$(/bin/grep -c '^processor' /proc/cpuinfo)

	[[ $a -eq 0 ]] && a=$(/bin/grep -c '^Processor' /proc/cpuinfo)

	printf '%s' "$a"

	}

SetTraps()
	{

	trap CaughtSIGHUP SIGHUP
	trap CaughtSIGINT SIGINT
	trap CaughtEXIT EXIT

	}

CaughtSIGHUP()
	{

	trap - SIGHUP

	DisplayCommitToLog '* caught SIGHUP: abort.'
	SetServiceResultAsAborted

	exit

	}

CaughtSIGINT()
	{

	trap - SIGINT

	DisplayCommitToLog '* caught SIGINT: abort.'
	SetServiceResultAsAborted

	exit

	}

CaughtEXIT()
	{

	trap - EXIT

	if IsServiceResultInProgress; then
		DisplayCommitToLog '* caught EXIT: abort.'
		SetServiceResultAsAborted
	fi

	}

ProcessArgs()
	{

	if IsGitApp; then
		local test_branch=$(/sbin/getcfg $r_qpkg_name Git_Branch -d unknown -f /etc/config/qpkg.conf)

		if [[ $test_branch = unknown ]]; then
			/sbin/setcfg $r_qpkg_name Git_Branch $source_git_branch -f /etc/config/qpkg.conf
		else
			source_git_branch=$test_branch
		fi
	fi

	if IsNotError; then
		local user_arg=${r_user_args_raw%% *}		# Only process first argument.

		case $user_arg in
			?(--)activate|?(--)start)
				IsSU ||	exit

				SetServiceAction start

				if IsQPKGEnabled; then
					SetTraps
					StartQPKG
				else
					ShowDisabledPrompt
					SetError
				fi
				;;
			?(-)b|?(--)backup?(-config))
				IsSU ||	exit

				if IsSupportBackup; then
					SetServiceAction backup
					SetTraps
					StopQPKG
					BackupConfig
					IsQPKGEnabled && StartQPKG
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(--)clean|?(--)update|?(--)upgrade)
				IsSU ||	exit

				if IsSourcedOnline; then
					SetServiceAction clean
					SetTraps
					StopQPKG
					[[ $r_qpkg_name = nzbToMedia ]] && BackupConfig
					CleanLocalRepo
					IsQPKGEnabled && StartQPKG
					[[ $r_qpkg_name = nzbToMedia ]] && RestoreConfig
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(--)deactivate|?(--)stop)
				IsSU ||	exit

				SetServiceAction stop
				SetTraps
				StopQPKG
				;;
			?(--)disable)
				IsSU ||	exit

				SetServiceAction disable
				SetTraps
				/sbin/qpkg_service disable "$r_qpkg_name"

				if IsNotQPKGEnabled; then
					ShowDisabled
				else
					ShowDisableFailed
					SetError
				fi
				;;
			?(--)disable-auto-update)
				IsSU ||	exit

				if IsSupportAutoUpdate; then
					SetServiceAction disable-auto-update
					SetTraps
					DisableAutoUpdate
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(--)enable)
				IsSU ||	exit

				SetServiceAction enable
				SetTraps
				/sbin/qpkg_service enable "$r_qpkg_name"

				if IsQPKGEnabled; then
					ShowEnabled
				else
					ShowEnableFailed
					SetError
				fi
				;;
			?(--)enable-auto-update)
				IsSU ||	exit

				if IsSupportAutoUpdate; then
					SetServiceAction enable-auto-update
					SetTraps
					EnableAutoUpdate
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(--)help)
				ShowHelp
				;;
			?(-)+(l|L)|?(--)log)
				SetServiceAction log
				ViewLog
				;;
			?(-)r|?(--)reactivate|?(--)restart)
				IsSU ||	exit

				SetServiceAction restart

				if IsQPKGEnabled; then
					SetTraps
					StopQPKG && StartQPKG
				else
					ShowDisabledPrompt
					SetError
				fi
				;;
			remove)			# Only called by the QDK '.uninstall.sh' script.
				SetServiceAction uninstall
				;;
			?(--)reset-action)
				IsSU ||	exit

				if IsSupportActions; then
					ResetServiceAction
					exit
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(--)reset-config)
				IsSU ||	exit

				if IsSupportReset; then
					SetServiceAction reset
					SetTraps
					StopQPKG
					ResetConfig
					IsQPKGEnabled && StartQPKG
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(--)restore?(-config))
				IsSU ||	exit

				if IsSupportBackup; then
					SetServiceAction restore
					SetTraps
					StopQPKG
					RestoreConfig
					IsQPKGEnabled && StartQPKG
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
				;;
			?(-)s|?(--)status)
				SetStatusGet
				StatusQPKG
				;;
			uninstall)
				: # Ignore.
				;;
			?(-)+(v|V)|?(--)version?(s))
				Display "package: '$r_qpkg_version'"
				Display "service: '$r_service_script_version'"
				Display "library: '$r_service_library_version'"
				;;
			*)
				if [[ -z $user_arg ]]; then
					ShowHelp
				else
					SetServiceAction unsupported
					ShowUnsupportedAction "$user_arg"
				fi
		esac
	fi

	if IsNotLog && IsNotNone; then
		if IsError; then
			SetServiceResultAsFailed

			exit 1
		else
			SetServiceResultAsOK
		fi
	fi

	exit 0

	}

InitLibrary
