#!/usr/bin/env bash
#* Please don't edit this file directly, it was built/modified programmatically with the 'build-qpkgs.sh' script. (source: 'service-library.source')
#* service.lib
#* copyright (C) 2017-2024 OneCD.
#* Contact:
#*   one.cd.only@gmail.com
#* Description:
#*   A library of common bash functions used by many sherpa QPKG service-scripts.
#*   Each QPKG has a copy for use only by that QPKG's service-script.
#* Project:
#*	 https://git.io/sherpa
#* Forum:
#*	 https://forum.qnap.com/viewtopic.php?t=132373
#* Tested on:
#*	 GNU bash, version 3.2.57(2)-release (i686-pc-linux-gnu)
#*	 GNU bash, version 3.2.57(1)-release (aarch64-QNAP-linux-gnu)
#*	   Copyright (C) 2007 Free Software Foundation, Inc.
#*   ... and periodically on:
#*	 GNU bash, version 5.0.17(1)-release (aarch64-openwrt-linux-gnu)
#*	   Copyright (C) 2019 Free Software Foundation, Inc.
#* License:
#*   This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
#*	 This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#*	 You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/
set -o nounset -o pipefail
shopt -s extglob
[[ $- != *m* ]] || set +m
ln -fns /proc/self/fd /dev/fd
readonly r_service_library_version='240914'
InitLibrary()
{
IsQNAP || exit
[[ ${DEBUG_QPKG:-} = true ]] && debug=true || debug=false
local re=''
for re in \\bd\\b \\bD\\b \\bdebug\\b \\bdbug\\b \\bverbose\\b;do
[[ $r_user_args_raw =~ $re ]] || continue
debug=true
break
done
UnsetError
readonly r_backup_path=$(/sbin/getcfg SHARE_DEF defVolMP -f /etc/config/def_share.info)/.qpkg_config_backup
readonly r_opkg_path=/opt/bin:/opt/sbin
export PATH=$r_opkg_path:$(/bin/sed "s|$r_opkg_path||" <<< "$PATH")
readonly r_qpkg_path=$(/sbin/getcfg $r_qpkg_name Install_Path -f /etc/config/qpkg.conf)
readonly r_qpkg_config_path=$r_qpkg_path/config
export HOME=$r_qpkg_config_path
readonly r_qpkg_temp_path=$r_qpkg_path/tmp
readonly r_appl_version_store_pathfile=$r_qpkg_path/version.stored
readonly r_screen_conf_pathfile=$r_qpkg_path/screen.conf
readonly r_service_action_pathfile=/var/log/$r_qpkg_name.action
readonly r_service_log_pathfile=/var/log/$r_qpkg_name.log
readonly r_service_result_pathfile=/var/log/$r_qpkg_name.result
readonly r_service_screen_log_pathfile=/var/log/$r_qpkg_name.screen.log
readonly r_chars_regular_prompt='$ '
readonly r_chars_sudo_prompt="${r_chars_regular_prompt}sudo "
readonly r_chars_super_prompt='# '
readonly r_debug_log_datawidth=100
readonly r_nas_firmware_version=$(/sbin/getcfg System Version -f /etc/config/uLinux.conf)
readonly r_qpkg_version=$(/sbin/getcfg $r_qpkg_name Version -d unknown -f /etc/config/qpkg.conf)
pip_cache_path=undefined
qpkg_repo_path=undefined
qpkg_wheels_path=undefined
venv_path=undefined
qpkg_ini_file=config.ini
app_version_pathfile=undefined
daemon_check_pathfile=undefined
daemon_exec_pathfile=undefined
daemon_pid_pathfile=/var/run/$r_qpkg_name.pid
daemon_script_pathfile=undefined
launcher_pathfile=undefined
qpkg_backup_pathfile=$r_backup_path/$r_qpkg_name.config.tar.gz
qpkg_ini_pathfile=$r_qpkg_config_path/$qpkg_ini_file
qpkg_ini_default_pathfile=$qpkg_ini_pathfile.def
userlink_pathfile=undefined
venv_pip_pathfile=undefined
venv_python_pathfile=undefined
allow_access_to_sys_packages=true
can_restart_to_update=false
compare_release_filename=false
daemon_pidfile_is_managed_by_app=false
install_pip_deps=false
package_is_exec=false
recheck_daemon_pid_after_kill=false
recheck_daemon_pid_after_launch=false
resolve_remote_url=false
run_daemon_in_screen_session=false
silence_pypi_errors=true
daemon_port=0
interpreter=undefined
nice_daemon_to=0
orig_daemon_service_script=undefined
pid_start_wait_seconds=60
port_check_timeout_seconds=120
remote_arch=undefined
source_arch=undefined
source_git_branch=undefined
source_git_branch_depth=undefined
ui_listening_address=undefined
ui_port=0
ui_port_secure=0
remote_url=undefined
source_git_url=undefined
daemon_launch_cmd=undefined
get_app_version_cmd=undefined
get_daemon_port_cmd=undefined
get_ui_listening_address_cmd=undefined
get_ui_port_cmd=undefined
get_ui_port_secure_cmd=undefined
get_ui_port_secure_enabled_test_cmd=undefined
InitService
OSIsSupportSecureDownload && curl_insecure_arg='' || curl_insecure_arg=' --insecure'
get_remote_filename_timeout_seconds=5
new_env=false
pyver=''
service_action=unspecified
service_result=undefined
MakePaths
EnsureConfigFileExists
GetAppVersion
DisableOpkgDaemonStart
IsSupportAutoUpdate && IsAutoUpdateMissing && EnableAutoUpdate >/dev/null
if [[ $run_daemon_in_screen_session = true && ! -e $r_screen_conf_pathfile ]];then
echo -e "logfile ${r_service_screen_log_pathfile}\nlogfile flush 1\nlog on" > "$r_screen_conf_pathfile"
fi
}
StartQPKG()
{
IsNotError || return
if IsReinstall || IsUpgrade;then
return
fi
IsNotStart && IsNotRestart && QPKGWasNotActive && return
IsNotRestart && IsDaemon && IsDaemonActive && return
IsStart && ShowQPKGStates
if [[ $(type -t StartQPKGCustom) = function ]];then
StartQPKGCustom
else
StartQPKGLibrary
fi
}
StartQPKGLibrary()
{
if IsGitApp;then
CloneGitRepo || return
fi
if IsOnlineReleasePackage;then
RefreshReleasePackageFiles || return
fi
if IsVirtualPythonEnv && IsNotVirtualPythonEnvExist;then
CreateVirtualPythonEnv || return
InstallPythonPackages || return
fi
if IsNotDaemon;then
CreateUserlinkToExec
return
fi
EnsureConfigFileExists
LoadPorts app || return
CheckPortsAvailable || return
StartDaemon
return
}
StopQPKG()
{
IsNotError || return
IsNotRestart && IsDaemon && IsNotDaemonActive && return
if IsStop || IsRestart;then
ShowQPKGStates
fi
if [[ $(type -t StopQPKGCustom) = function ]];then
StopQPKGCustom
else
StopQPKGLibrary
fi
}
StopQPKGLibrary()
{
if IsNotDaemon;then
RemoveUserlinkToExec
return
fi
RefreshPidFile
if IsDaemon && IsDaemonActive;then
SetQPKGWasActive
StopDaemon
fi
return
}
StatusQPKG()
{
IsNotError || return
ShowQPKGStates
if [[ $(type -t StatusQPKGCustom) = function ]];then
StatusQPKGCustom
else
StatusQPKGLibrary
fi
}
StatusQPKGLibrary()
{
RefreshPidFile
if IsDaemon && IsDaemonActive;then
LoadPorts app
CheckPorts || exit
else
exit 1
fi
exit 0
}
CreateUserlinkToExec()
{
if [[ $userlink_pathfile != undefined ]];then
if [[ ! -L $userlink_pathfile && -e $launcher_pathfile ]];then
ln -s "$launcher_pathfile" "$userlink_pathfile"
if [[ -L $userlink_pathfile ]];then
DisplayCommitToLog "= symlink created: '$userlink_pathfile'"
else
DisplayErrCommitAllLogs "= unable to create symlink to '$r_qpkg_name' launcher"
SetError;return 1
fi
else
DisplayCommitToLog "- symlink exists: '$userlink_pathfile'"
fi
return
fi
}
RemoveUserlinkToExec()
{
if [[ $userlink_pathfile != undefined ]];then
if [[ -L $userlink_pathfile ]];then
rm -f "$userlink_pathfile"
DisplayCommitToLog "= symlink removed: '$userlink_pathfile'"
fi
fi
}
CreateVirtualPythonEnv()
{
new_env=false
local a=''
local b=$venv_path/pip.conf
[[ $allow_access_to_sys_packages = true ]] && a=' --system-site-packages'
if IsNotVirtualPythonEnvExist;then
DisplayRunAndLog 'create new virtual Python environment' "export PIP_CACHE_DIR=$pip_cache_path VIRTUALENV_OVERRIDE_APP_DATA=$pip_cache_path;$interpreter -m virtualenv ${venv_path}${a}" log:failure-only
new_env=true
if [[ ! -e $b ]];then
DisplayRunAndLog "create QPKG 'pip' config" "echo \"[global]\" > $b" log:failure-only
DisplayRunAndLog "add '$(/usr/bin/basename "$pip_cache_path")' as 'pip' cache" "echo \"cache-dir = $pip_cache_path\" >> $b" log:failure-only
if [[ -d $qpkg_wheels_path ]];then
DisplayRunAndLog "add '$(/usr/bin/basename "$qpkg_wheels_path")' to 'pip' search path" "echo \"find-links = $qpkg_wheels_path\" >> $b" log:failure-only
fi
fi
fi
return 0
}
StartDaemon()
{
local a='start daemon'
local b=$daemon_launch_cmd
if [[ $run_daemon_in_screen_session = true ]];then
a+=' (in screen session)'
rm -f "${r_service_screen_log_pathfile:?}"
fi
if ((nice_daemon_to != 0)) && ((nice_daemon_to >= -20)) && ((nice_daemon_to <= 19)) && [[ -e /opt/bin/nice ]];then
b="/opt/bin/nice -n $nice_daemon_to bash -c \"$daemon_launch_cmd\""
DisplayCommitToLog "- nice daemon to: $nice_daemon_to"
fi
if ! DisplayRunAndLog "$a" "$b" log:failure-only "$run_daemon_in_screen_session";then
[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$r_service_screen_log_pathfile"
SetError;return 1
fi
IsDaemonActive
WaitForDaemonPid
WaitForStartPid
if ! IsDaemonActive;then
DisplayErrCommitAllLogs 'daemon has failed to start!'
[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$r_service_screen_log_pathfile"
SetError;return 1
fi
if ! CheckPorts;then
DisplayErrCommitAllLogs 'port tests failed!'
[[ $run_daemon_in_screen_session = true ]] && AddFileToDebug "$r_service_screen_log_pathfile"
SetError;return 1
fi
CommitInfoToSysLog "$a: OK"
}
StopDaemon()
{
[[ -e $daemon_pid_pathfile ]] || return
local a='stop daemon'
local -i b=$(CalcAdaptiveSeconds 120)
local -i c=0
local -i d=0
d=$(<$daemon_pid_pathfile)
[[ $d -gt 1 ]] || return
DisplayWaitCommitToLog "> $a PID '${d}' with SIGTERM (no-more than $b second$(Pluralise "$b")):"
kill "$d"
while true;do
while [[ -d /proc/$d ]];do
/bin/sleep 1
((c++))
DisplayWait "$c,"
if [[ $c -ge $b ]];then
DisplayCommitToLog 'failed!'
DisplayCommitToLog "> $a PID '${d}' with SIGKILL:"
kill -9 "$d" 2> /dev/null
[[ -f $daemon_pid_pathfile ]] && rm -f "$daemon_pid_pathfile"
break 2
fi
done
[[ -f $daemon_pid_pathfile ]] && rm -f "$daemon_pid_pathfile"
Display OK
CommitToLog "stopped in $c second$(Pluralise "$c")"
CommitInfoToSysLog "$a: OK"
break
done
WaitForKillPid
if IsDaemonActive;then
SetError;return 1
fi
}
RefreshReleasePackageFiles()
{
local extract_release_package=false
local refresh_release_package=false
local release_package_filename=''
local release_package_name_ref_pathfilename=''
local release_package_pathfile=$r_qpkg_temp_path/source.package
local release_package_url=''
if IsAutoUpdate || [[ ! -e $release_package_pathfile ]];then
if [[ $resolve_remote_url = true ]];then
refresh_release_package=true
if IsSiteUp "$remote_url";then
release_package_url=$(RequestLatestReleaseURL "$remote_url" "$remote_arch")
else
DisplayErrCommitAllLogs '! unable to access remote site'
fi
else
release_package_url=$remote_url
fi
if [[ $compare_release_filename = true ]];then
DisplayWaitCommitToLog "> get latest remote release package filename (no-more than $get_remote_filename_timeout_seconds seconds):"
if IsSiteUp "$remote_url";then
release_package_filename=$(RequestLatestReleaseFilename "$remote_url" "$remote_arch")
if [[ -n $release_package_filename ]];then
DisplayCommitToLog "'$release_package_filename'"
else
DisplayErrCommitAllLogs '! unable to get latest remote release package filename'
fi
else
DisplayErrCommitAllLogs '! unable to access remote site'
fi
if [[ -z $release_package_filename && -n $release_package_url && $release_package_url != undefined ]];then
release_package_filename=$(/usr/bin/basename "$release_package_url")
fi
if [[ -z $release_package_name_ref_pathfilename && -n $release_package_filename && -n $release_package_url && $release_package_url != undefined ]];then
release_package_name_ref_pathfilename=$(/usr/bin/dirname "$release_package_pathfile")/$release_package_filename
fi
if [[ -n $release_package_filename && -n $release_package_name_ref_pathfilename ]];then
DisplayWaitCommitToLog '- release package name reference exists locally:'
if [[ -e $release_package_name_ref_pathfilename ]];then
DisplayCommitToLog true
else
DisplayCommitToLog false
refresh_release_package=true
rm -f "$release_package_pathfile"
fi
fi
fi
fi
DisplayWaitCommitToLog '- release package exists locally:'
if [[ -e $release_package_pathfile ]];then
DisplayCommitToLog true
else
DisplayCommitToLog false
refresh_release_package=true
fi
if [[ ! -e $release_package_pathfile && -n $release_package_url ]] || [[ $refresh_release_package = true ]];then
DownloadReleasePackage "$release_package_url" "$release_package_pathfile"
if [[ -e $release_package_pathfile ]] && [[ ! -e $daemon_exec_pathfile || $(($(/bin/date +%s)-$(/usr/bin/stat "$release_package_pathfile" -c %Y))) -lt 10 ]];then
extract_release_package=true
fi
fi
if IsPathEmpty "$qpkg_repo_path";then
extract_release_package=true
fi
if [[ $extract_release_package = true && -e $release_package_pathfile ]];then
if IsReleaseAnArchive;then
ExtractReleasePackage "$release_package_pathfile" "$release_package_name_ref_pathfilename"
else
MakeExecReleasePackage "$release_package_pathfile" "$release_package_name_ref_pathfilename"
fi
fi
if [[ -d $qpkg_repo_path ]];then
if IsPathEmpty "$qpkg_repo_path";then
DisplayErrCommitAllLogs "'local repository files do not exist'"
SetError;return 1
fi
else
DisplayErrCommitAllLogs "'local repository path does not exist'"
SetError;return 1
fi
return 0
}
CheckPortsAvailable()
{
local a=''
if [[ $daemon_port -le 0 && $ui_port -le 0 && $ui_port_secure -le 0 ]];then
DisplayErrCommitAllLogs "'no port specified'"
SetError;return 1
elif IsNotPortAvailable $ui_port || IsNotPortAvailable $ui_port_secure;then
DisplayErrCommitAllLogs "ports '$ui_port' or '$ui_port_secure' are already in-use"
a=$(/usr/sbin/lsof -i :$ui_port -Fp)
DisplayErrCommitAllLogs "- process details for port '$ui_port': '${a}': PID '$([[ -n ${a:-} ]] && /bin/tr '\000' ' ' </proc/"${a/p/}"/cmdline)'"
a=$(/usr/sbin/lsof -i :$ui_port_secure -Fp)
DisplayErrCommitAllLogs "- process details for secure port '$ui_port_secure': PID '${a}': '$([[ -n ${a:-} ]] && /bin/tr '\000' ' ' </proc/"${a/p/}"/cmdline)'"
SetError;return 1
fi
}
ShowHelp()
{
Display "$(TextBrightWhite "$(/usr/bin/basename "$0")") v$r_service_script_version • a service control script for the $(FormatAsPackageName $r_qpkg_name) QPKG"
Display
Display "Usage: $0 [ACTION] [OPTION]"
Display
Display '[ACTION] must be one of the following:'
DisplayAsHelp 'activate, start' "start $(FormatAsPackageName $r_qpkg_name) if inactive"
IsSupportBackup && DisplayAsHelp 'b, backup' "backup current $(FormatAsPackageName $r_qpkg_name) configuration to persistent storage"
IsSourcedOnline && DisplayAsHelp clean "delete & re-download $(FormatAsPackageName $r_qpkg_name) files from source. Configuration will be retained"
DisplayAsHelp 'deactivate, stop' "stop $(FormatAsPackageName $r_qpkg_name) if active"
DisplayAsHelp disable "disable $(FormatAsPackageName $r_qpkg_name) to prevent it starting (on NAS bootup)"
IsSupportAutoUpdate && DisplayAsHelp disable-auto-update "don't auto-update $(FormatAsPackageName $r_qpkg_name) before starting it"
DisplayAsHelp enable "enable $(FormatAsPackageName $r_qpkg_name) so it can be started"
IsSupportAutoUpdate && DisplayAsHelp enable-auto-update "auto-update $(FormatAsPackageName $r_qpkg_name) before starting (default)"
DisplayAsHelp 'l, L, log' 'display the service-script log'
DisplayAsHelp 'r, reactivate, restart' "stop, then start $(FormatAsPackageName $r_qpkg_name)"
IsSupportActions && DisplayAsHelp reset-action 'clear the current service-script action and action result'
IsSupportReset && DisplayAsHelp reset-config "revert $(FormatAsPackageName $r_qpkg_name) configuration, databases and history to defaults"
IsSupportBackup && DisplayAsHelp restore 'restore a previously saved configuration from persistent storage'
DisplayAsHelp 's, status' "check if $(FormatAsPackageName $r_qpkg_name) application is active. Returns \$? = 0 if active, 1 if not"
DisplayAsHelp 'v, V, version' 'display the package version numbers'
Display
Display '[OPTION] may be one of the following:'
DisplayAsHelp 'd, D, debug, verbose' "execute the specified [ACTION] in debug mode"
Display
}
InstallPythonPackages()
{
IsVirtualPythonEnv || return 0
local a=''
local cmd=''
local default_essential_modules_pathfile=$r_qpkg_path/pip-essential.txt
local default_recommended_modules_pathfile=$r_qpkg_path/pip-recommended.txt
local default_requirements_modules_pathfile=$r_qpkg_path/pip-requirements.txt
local essential_modules_pathfile=$qpkg_repo_path/pip-essential.txt
local excluded_modules_pathfile=$r_qpkg_path/pip-exclusions.txt
local module_exclusions=''
local no_pip_deps=' --no-deps'
local no_pips_installed=true
local pyproject_pathfile=$qpkg_repo_path/pyproject.toml
local re=''
local recommended_modules_pathfile=$qpkg_repo_path/recommended.txt
local rename_modules_pathfile=$r_qpkg_path/pip-rename.txt
local requirements_modules_pathfile=$qpkg_repo_path/requirements.txt
[[ $install_pip_deps = true ]] && no_pip_deps=''
if IsNotVirtualPythonEnvExist;then
DisplayErrCommitAllLogs "unable to install addons: 'virtual Python environment does not exist'"
SetError;return 1
fi
IsNotAutoUpdate && [[ $new_env = false ]] && return 0
if [[ $r_qpkg_name = OWatcher3 ]];then
DisplayRunAndLog "KLUDGE: install 'm2r' PyPI module first" "$venv_pip_pathfile install${no_pip_deps} --no-input m2r" log:failure-only
if [[ $? -gt 0 && $silence_pypi_errors = false ]];then
CommitWarnToSysLog "'mr2' PyPI module installation failed."
fi
fi
[[ ! -e $default_essential_modules_pathfile && -e $essential_modules_pathfile && -d $(/usr/bin/dirname "$default_essential_modules_pathfile") ]] && cp -f "$essential_modules_pathfile" "$default_essential_modules_pathfile"
[[ -e $default_essential_modules_pathfile ]] && essential_modules_pathfile=$default_essential_modules_pathfile
[[ ! -e $default_requirements_modules_pathfile && -e $requirements_modules_pathfile && -d $(/usr/bin/dirname "$default_requirements_modules_pathfile") ]] && cp -f "$requirements_modules_pathfile" "$default_requirements_modules_pathfile"
[[ -e $default_requirements_modules_pathfile ]] && requirements_modules_pathfile=$default_requirements_modules_pathfile
[[ ! -e $default_recommended_modules_pathfile && -e $recommended_modules_pathfile && -d $(/usr/bin/dirname "$default_recommended_modules_pathfile") ]] && cp -f "$recommended_modules_pathfile" "$default_recommended_modules_pathfile"
[[ -e $default_recommended_modules_pathfile ]] && recommended_modules_pathfile=$default_recommended_modules_pathfile
if [[ -e $excluded_modules_pathfile ]];then
module_exclusions=$(/bin/tr '\n' ' ' <<< "$(StripComments "$(<"$excluded_modules_pathfile")")")
module_exclusions=${module_exclusions%* }
if [[ -n $module_exclusions ]];then
re="^${module_exclusions// /\$\|^}$"
fi
if [[ -n $re ]];then
for a in $essential_modules_pathfile $requirements_modules_pathfile $recommended_modules_pathfile $pyproject_pathfile;do
if [[ -e $a ]];then
if [[ -e /opt/bin/sed ]];then
cmd="/opt/bin/sed -i '/${re}/Id' $a"
else
cmd="/bin/sed -i '/${re}/d' $a"
fi
DisplayRunAndLog "exclude problematic PyPI modules from '$(/usr/bin/basename "$a")'" "$cmd" log:failure-only
fi
done
fi
fi
for a in $essential_modules_pathfile $requirements_modules_pathfile $recommended_modules_pathfile;do
if [[ -e $a ]];then
DisplayRunAndLog "install PyPI modules from '$(/usr/bin/basename "$a")'" "$venv_pip_pathfile install${no_pip_deps} --no-input --upgrade pip -r $a" log:failure-only
if [[ $? -gt 0 && $silence_pypi_errors = false ]];then
CommitWarnToSysLog '= PyPI module installation failed.'
fi
no_pips_installed=false
fi
done
if [[ -e $rename_modules_pathfile ]];then
for a in $(StripComments "$(<"$rename_modules_pathfile")");do
RenameSharedObjectFile "$a"
done
fi
if IsSupportGetAppVersion;then
GetAppVersion
if [[ $new_env = false && -e $r_appl_version_store_pathfile && $(<"$r_appl_version_store_pathfile") != "$app_version" ]];then
DisplayRunAndLog 'clean Python bytecode files' "/opt/bin/find $qpkg_repo_path -type d -name '__pycache__' -print0 | xargs -I {} -0 rm -rf '{}'
" log:failure-only
fi
if [[ ! -e $r_appl_version_store_pathfile || $(<"$r_appl_version_store_pathfile") != "$app_version" ]];then
DisplayRunAndLog 'generate language translations' "cd $qpkg_repo_path;$venv_python_pathfile $qpkg_repo_path/tools/make_mo.py" log:failure-only
fi
SaveAppVersion
fi
return 0
}
StripComments()
{
[[ -n $1 ]] || return
local a=$1
a=$(/bin/sed -e '/^#[[:space:]].*/d;/#$/d;s/[[:space:]]#[[:space:]].*//' <<< "$a")
a=$(/bin/sed -e 's/^[[:space:]]*//' <<< "$a")
a=$(/bin/sed 's/[[:space:]]*$//' <<< "$a")
a=$(/bin/sed "/^$/d" <<< "$a")
echo "$a"
}
BackupConfig()
{
if ! DisplayRunAndLog 'update configuration backup' "/bin/tar --create --gzip --file=$qpkg_backup_pathfile --directory=$r_qpkg_path/config ." log:failure-only;then
SetError;return 1
fi
}
RestoreConfig()
{
if [[ ! -f $qpkg_backup_pathfile ]];then
DisplayErrCommitAllLogs "unable to restore configuration: 'no backup file was found'"
SetError;return 1
fi
if ! DisplayRunAndLog 'restore configuration backup' "/bin/tar --extract --gzip --file=$qpkg_backup_pathfile --directory=$r_qpkg_path/config" log:failure-only;then
SetError;return 1
fi
}
ResetConfig()
{
if ! DisplayRunAndLog 'reset configuration' "mv $qpkg_ini_default_pathfile $r_qpkg_path;rm -rf $r_qpkg_path/config/*; mkdir -p $(/usr/bin/dirname "$qpkg_ini_default_pathfile"); mv $r_qpkg_path/$(/usr/bin/basename "$qpkg_ini_default_pathfile") $qpkg_ini_default_pathfile" log:failure-only; then
SetError;return 1
fi
}
MakePaths()
{
local a=''
if [[ -d $r_qpkg_path ]];then
for a in "$r_qpkg_temp_path" "$qpkg_repo_path" "$pip_cache_path" "$venv_path";do
[[ $a != undefined && ! -d $a ]] && mkdir -p "$a"
done
fi
[[ $r_backup_path != undefined && ! -d $r_backup_path ]] && mkdir -p "$r_backup_path"
}
LoadPorts()
{
case $1 in
app)
DisplayWaitCommitToLog '> load ports from configuration file:'
[[ $get_ui_port_cmd != undefined ]] && ui_port=$(eval "$get_ui_port_cmd")
[[ $get_ui_port_secure_cmd != undefined ]] && ui_port_secure=$(eval "$get_ui_port_secure_cmd")
DisplayCommitToLog OK
;;
qts)
DisplayWaitCommitToLog '> load UI ports from QPKG icon:'
ui_port=$(/sbin/getcfg $r_qpkg_name Web_Port -d 0 -f /etc/config/qpkg.conf)
ui_port_secure=$(/sbin/getcfg $r_qpkg_name Web_SSL_Port -d 0 -f /etc/config/qpkg.conf)
DisplayCommitToLog OK
;;
*)
DisplayErrCommitAllLogs "unable to load ports: action '$1' is unrecognised"
SetError;return 1
esac
[[ $get_daemon_port_cmd != undefined ]] && daemon_port=$(eval "$get_daemon_port_cmd")
[[ $get_ui_listening_address_cmd != undefined ]] && ui_listening_address=$(eval "$get_ui_listening_address_cmd")
ui_port=${ui_port//[!0-9]/}
[[ -z $ui_port || $ui_port -lt 0 || $ui_port -gt 65535 ]] && ui_port=0
ui_port_secure=${ui_port_secure//[!0-9]/}
[[ -z $ui_port_secure || $ui_port_secure -lt 0 || $ui_port_secure -gt 65535 ]] && ui_port_secure=0
daemon_port=${daemon_port//[!0-9]/}
[[ -z $daemon_port || $daemon_port -lt 0 || $daemon_port -gt 65535 ]] && daemon_port=0
[[ -z $ui_listening_address ]] && ui_listening_address=undefined
return 0
}
GetAppVersion()
{
if IsSupportGetAppVersion && [[ -e $app_version_pathfile ]];then
app_version=$(eval "$get_app_version_cmd")
return 0
else
app_version=unknown
return 1
fi
}
ShowQPKGStates()
{
DisplayWaitCommitToLog '- QPKG enabled:'
if IsQPKGEnabled;then
DisplayCommitToLog true
else
DisplayCommitToLog false
fi
if IsSupportAutoUpdate;then
DisplayWaitCommitToLog '- application auto-update:'
if IsAutoUpdate;then
DisplayCommitToLog true
else
DisplayCommitToLog false
fi
fi
if IsGitApp;then
DisplayCommitToLog "- active git branch: '$(GetPathGitBranch "$qpkg_repo_path")'"
fi
}
DisableOpkgDaemonStart()
{
if [[ $orig_daemon_service_script != undefined && -x $orig_daemon_service_script ]];then
$orig_daemon_service_script stop
chmod -x "$orig_daemon_service_script"
fi
}
CloneGitRepo()
{
IsGitApp || return 0
local active_branch=$(GetPathGitBranch "$qpkg_repo_path")
local branch_depth='--depth 1'
[[ $source_git_branch_depth = single-branch ]] && branch_depth='--single-branch'
local branch_switch=false
local new_branch=false
WaitForGit || return
if [[ -d $qpkg_repo_path/.git ]];then
if [[ $active_branch != "$source_git_branch" ]];then
DisplayCommitToLog "- new git branch specified: '$source_git_branch'"
branch_switch=true
[[ $r_qpkg_name = nzbToMedia ]] && BackupConfig
CleanLocalRepo
fi
fi
if [[ ! -d $qpkg_repo_path/.git ]];then
DisplayRunAndLog "create $(FormatAsPackageName "$r_qpkg_name") from remote repository" "cd /tmp;/opt/bin/git clone --branch $source_git_branch $branch_depth -c advice.detachedHead=false $source_git_url $qpkg_repo_path" log:failure-only
new_branch=true
else
if IsAutoUpdate;then
DisplayRunAndLog "update $(FormatAsPackageName "$r_qpkg_name") from remote repository" "cd /tmp;/opt/bin/git -C $qpkg_repo_path clean -f; /opt/bin/git -C $qpkg_repo_path reset --hard origin/$source_git_branch; /opt/bin/git -C $qpkg_repo_path pull" log:failure-only
fi
fi
IsAutoUpdate && [[ $new_branch = true || $branch_switch = true ]] && DisplayCommitToLog "- active git branch: '$(GetPathGitBranch "$qpkg_repo_path")'"
[[ $branch_switch = true && $r_qpkg_name = nzbToMedia ]] && RestoreConfig
return 0
}
CleanLocalRepo()
{
if [[ -z $r_qpkg_path || -z $r_qpkg_name ]] || IsNotSourcedOnline;then
SetError;return 1
fi
(IsGitApp || IsOnlineReleasePackage) && DisplayRunAndLog 'clean local repository' "rm -rf \"$qpkg_repo_path\"" log:failure-only
IsVirtualPythonEnv && [[ -d $venv_path ]] && DisplayRunAndLog 'clean virtual Python environment' "rm -rf \"$venv_path\"" log:failure-only
IsUsePipCache && [[ -d $pip_cache_path ]] && DisplayRunAndLog 'clean PyPI cache' "rm -rf \"$pip_cache_path\"" log:failure-only
[[ -e $r_appl_version_store_pathfile ]] && DisplayRunAndLog 'remove application version' "rm -f \"$r_appl_version_store_pathfile\"" log:failure-only
IsUseTemp && [[ -d $r_qpkg_temp_path ]] && DisplayRunAndLog 'clean temp path' "rm -rf \"$r_qpkg_temp_path\"" log:failure-only
MakePaths
}
WaitForGit()
{
if IsNotQPKGInstalled Entware;then
DisplayErrCommitAllLogs "'git' unavailable: 'Entware is not installed'"
SetError;return 1
fi
if IsNotQPKGEnabled Entware;then
DisplayErrCommitAllLogs "'git' unavailable: 'Entware is not enabled'"
SetError;return 1
fi
if WaitForFileToAppear '/opt/bin/git' 300;then
export PATH=$r_opkg_path:$(/bin/sed "s|$r_opkg_path||" <<< "$PATH")
return 0
fi
SetError;return 1
}
RefreshPidFile()
{
local -i a=0
if [[ -e $daemon_pid_pathfile && ! -d /proc/"$(<$daemon_pid_pathfile)" ]];then
rm -f "$daemon_pid_pathfile"
fi
if [[ $daemon_check_pathfile != undefined ]];then
a=$(FindPid "$daemon_check_pathfile")
else
a=$(FindPid "$daemon_exec_pathfile" "$daemon_script_pathfile")
fi
[[ -n $a && $a -gt 0 ]] && echo "$a" > "$daemon_pid_pathfile"
}
FindPid()
{
[[ -n ${1:-} ]] || return
local -i a=0
local b=''
[[ -n ${2:-} && $2 != undefined ]] && b=$2
for a in $(/bin/pidof "$(/usr/bin/basename "$1")");do
[[ $a -gt 1 ]] || continue
[[ -d /proc/$a ]] || continue
[[ -e /proc/$a/cmdline && -L /proc/$a/exe ]] || continue
[[ $(</proc/$a/cmdline) =~ $1 || $(/usr/bin/readlink /proc/$a/exe) = "$1" ]] || continue
if [[ -n $b ]];then
[[ $(</proc/$a/cmdline) =~ $b ]] || continue
fi
printf '%s' "$a"
return
done
return 1
}
WaitForStartPid()
{
local -i a=$(CalcAdaptiveSeconds 10)
local -i i=0
if [[ $daemon_pidfile_is_managed_by_app = true ]];then
if WaitForFileToAppear "$daemon_pid_pathfile" "$(CalcAdaptiveSeconds "$pid_start_wait_seconds")";then
/bin/sleep 1
fi
fi
if [[ $recheck_daemon_pid_after_launch = true ]];then
DisplayWaitCommitToLog "> wait $a second$(Pluralise "$a") to recheck PID:"
for ((i=1;i<=a; i++)); do
/bin/sleep 1
DisplayWait "$i,"
done
DisplayCommitToLog 'done'
fi
RefreshPidFile || return
}
WaitForKillPid()
{
local -i a=$(CalcAdaptiveSeconds 10)
local -i i=0
if [[ $recheck_daemon_pid_after_kill = true ]];then
DisplayWaitCommitToLog "> wait $a second$(Pluralise "$a") to recheck PID:"
for ((i=1;i<=a; i++)); do
/bin/sleep 1
DisplayWait "$i,"
done
DisplayCommitToLog 'done'
fi
! RefreshPidFile || return
}
WaitForDaemonPid()
{
local -i a=0
local -i i=0
if [[ -n ${1:-} ]];then
a=$1
else
a=$(CalcAdaptiveSeconds 120)
fi
if [[ ! -e $daemon_pid_pathfile ]];then
DisplayWaitCommitToLog "> wait for daemon process name to appear (no-more than $a second$(Pluralise "$a")):"
(
for ((i=1;i<=a; i++)); do
/bin/sleep 1
DisplayWait "$i,"
RefreshPidFile
if IsDaemonProcessActive;then
Display OK
CommitToLog "appeared in $i second$(Pluralise "$i")"
true
exit
fi
done
false
)
if [[ $? -ne 0 ]];then
DisplayErrCommitAllLogs "process not found! (exceeded timeout: $a second$(Pluralise "$a"))"
return 1
fi
fi
return 0
}
WaitForFileToAppear()
{
[[ -n $1 ]] || return
local -i a=0
local -i i=0
if [[ -n $2 ]];then
a=$2
else
a=30
fi
if [[ ! -e $1 ]];then
DisplayWaitCommitToLog "> wait for $1 to appear in filesystem (no-more than $a second$(Pluralise "$a")):"
(
for ((i=1;i<=a; i++)); do
/bin/sleep 1
DisplayWait "$i,"
if [[ -e $1 ]];then
Display OK
CommitToLog "visible after $i second$(Pluralise "$i")"
true
exit
fi
done
false
)
if [[ $? -ne 0 ]];then
DisplayErrCommitAllLogs "file $1 not found! (exceeded timeout: $a second$(Pluralise "$a"))"
return 1
fi
fi
DisplayCommitToLog "- file exists: '$1'"
return 0
}
ViewLog()
{
if [[ -e $r_service_log_pathfile ]];then
if [[ -e /opt/bin/less ]];then
LESSSECURE=1 /opt/bin/less +G --quit-on-intr --tilde --LINE-NUMBERS --RAW-CONTROL-CHARS --prompt ' use arrow-keys to scroll up-down left-right, press Q to quit' "$r_service_log_pathfile"
else
/bin/cat --number "$r_service_log_pathfile"
fi
else
Display "service log not found: $r_service_log_pathfile"
SetError;return 1
fi
return 0
}
EnsureConfigFileExists()
{
IsNotSupportReset && return
if IsNotConfigFound && IsDefaultConfigFound;then
DisplayCommitToLog '> no configuration file found: using default'
cp "${qpkg_ini_default_pathfile:?undefined}" "${qpkg_ini_pathfile:?undefined}"
fi
}
SaveAppVersion()
{
[[ $r_appl_version_store_pathfile != undefined ]] && echo "$app_version" > "$r_appl_version_store_pathfile"
}
DisplayRunAndLog()
{
local -r r_log_pathfile=$(/bin/mktemp /var/log/"${FUNCNAME[0]}"_XXXXXX)
local -i z=0
DisplayWaitCommitToLog "> $1:"
Executer "${2:?empty}" "$r_log_pathfile" "${4:-false}"
z=$?
if [[ $z -eq 0 ]];then
if [[ $debug = false ]];then
DisplayCommitToLog OK
else
Display "= $1: OK"
CommitToLog OK
fi
else
if [[ $debug = false ]];then
DisplayCommitToLog failed
else
DisplayCommitToLog "= $1: failed"
fi
fi
if [[ $z -eq 0 ]];then
[[ ${3:-} != log:failure-only ]] && AddFileToDebug "$r_log_pathfile"
else
AddFileToDebug "$r_log_pathfile"
fi
[[ -e $r_log_pathfile ]] && rm -f "$r_log_pathfile"
return $z
}
Executer()
{
local -r r_log_pathfile=$(/bin/mktemp /var/log/"${FUNCNAME[0]}"_XXXXXX)
local run_in_screen=${3:-false}
local -i z=0
FormatAsCommand "${1:?empty}" > "${2:?empty}"
if [[ $run_in_screen = true ]];then
if [[ $debug = true ]];then
Display
Display "{ exec (in screen session): '$1'"
fi
FormatAsCommand "$1" >> "$r_service_screen_log_pathfile"
/usr/sbin/screen -c "$r_screen_conf_pathfile" -dmLS "$r_qpkg_name" bash -c "$1"
z=$?
elif [[ $debug = true ]];then
Display
Display "{ exec: '$1'"
eval "$1 > >(/usr/bin/tee $r_log_pathfile) 2>&1"
z=${PIPESTATUS[0]}
else
(eval "$1" > "$r_log_pathfile" 2>&1)
z=$?
fi
if [[ -e $r_log_pathfile ]];then
FormatAsResultAndStdout "$z" "$(<"$r_log_pathfile")" >> "$2"
else
FormatAsResultAndStdout "$z" '<null>' >> "$2"
fi
if [[ $debug = true ]];then
if [[ $z -eq 0 ]];then
Display '} exec: completed OK'
else
Display '} exec: completed with errors'
fi
fi
[[ -e $r_log_pathfile ]] && rm -f "$r_log_pathfile"
return $z
}
ShowEnabled()
{
DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG is enabled."
}
ShowDisabled()
{
DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG is disabled."
}
ShowDisabledPrompt()
{
DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG is disabled. Please enable it first with: $0 enable"
}
ShowEnableFailed()
{
DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG enable failed."
}
ShowDisableFailed()
{
DisplayCommitToLog "= $(FormatAsPackageName "$r_qpkg_name") QPKG disable failed."
}
AddFileToDebug()
{
[[ -e ${1:?no filename supplied} ]] || return
local a=''
local debug_was_set=$debug
debug=false
DebugAsLog ''
DebugAsLog 'adding external log to main log ...'
DebugExtLogMinorSeparator
DebugAsLog "$(FormatAsLogFilename "$1")"
while read -r a;do
DebugAsLog "$a"
done < "$1"
DebugExtLogMinorSeparator
debug=$debug_was_set
}
DebugExtLogMinorSeparator()
{
DebugAsLog "$(DebugMinorSeparator)"
}
DebugBulletSeparatorWithText()
{
local a=''
[[ -n ${1:-} ]] && a=" ${1:-} "
local b=$(((r_debug_log_datawidth-${#a})/2))
local c=$((r_debug_log_datawidth-${#a}-b))
eval printf '%0.s•' "{1..$b}";printf '%s' "$a"; eval printf '%0.s•' "{1..$c}"; echo
}
DebugMinorSeparator()
{
eval printf '%0.s-' "{1..$r_debug_log_datawidth}"
}
DebugAsLog()
{
[[ -n ${1:-} ]] || return
DebugThis "(LL) $1"
}
DebugThis()
{
[[ $debug = true ]] && Display "${1:-}"
WriteAsDebug "${1:-}"
}
WriteAsDebug()
{
WriteToLog dbug "${1:-}"
}
WriteToLog()
{
printf "%-4s: %s\n" "$(StripANSICodes "${1:-}")" "$(StripANSICodes "${2:-}")" >> "$r_service_log_pathfile"
}
StripANSICodes()
{
if [[ -e /opt/bin/sed && -L /opt/etc/passwd ]];then
/opt/bin/sed -r 's/\x1b\[[0-9;]*m//g' <<< "${1:-}"
else
echo "${1:-}"
fi
}
Capitalise()
{
echo "$(Uppercase ${1:0:1})${1:1}"
}
Uppercase()
{
/bin/tr 'a-z' 'A-Z' <<< "$1"
}
Lowercase()
{
/bin/tr 'A-Z' 'a-z' <<< "$1"
}
ReWriteUIPorts()
{
[[ $get_daemon_port_cmd != undefined ]] && return
DisplayWaitCommitToLog '> update QPKG icon with UI ports:'
/sbin/setcfg $r_qpkg_name Web_Port "$ui_port" -f /etc/config/qpkg.conf
if IsSSLEnabled;then
/sbin/setcfg $r_qpkg_name Web_SSL_Port "$ui_port_secure" -f /etc/config/qpkg.conf
else
/sbin/setcfg $r_qpkg_name Web_SSL_Port '-2' -f /etc/config/qpkg.conf
fi
DisplayCommitToLog OK
}
CheckPorts()
{
local a=''
DisplayCommitToLog "- daemon listening address: '$ui_listening_address'"
if [[ $daemon_port -ne 0 ]];then
DisplayCommitToLog "- daemon port: '$daemon_port'"
if IsPortResponds $daemon_port;then
a="daemon port '$daemon_port'"
fi
else
DisplayWaitCommitToLog '- HTTPS port enabled:'
if IsSSLEnabled;then
DisplayCommitToLog true
DisplayCommitToLog "- HTTPS port: '$ui_port_secure'"
if IsPortSecureResponds $ui_port_secure;then
a="HTTPS port '$ui_port_secure'"
fi
else
DisplayCommitToLog false
fi
DisplayCommitToLog "- HTTP port: '$ui_port'"
if IsPortResponds $ui_port;then
[[ -n $a ]] && a+=' and '
a+="HTTP port '$ui_port'"
fi
fi
if [[ -z $a ]];then
DisplayErrCommitAllLogs 'no response on configured port(s)'
SetError;return 1
else
ReWriteUIPorts
return 0
fi
}
GetPythonVer()
{
local a=''
a=$(GetThisBinPath ${1:-python} &>/dev/null && ${1:-python} -V 2>&1 | /bin/sed 's|^Python ||;s|\.||g')
[[ -n $a ]] && echo "${a:0:3}"
}
GetThisBinPath()
{
[[ -n ${1:?null} ]] && command -v "$1" 2>&1
}
RenameSharedObjectFile()
{
[[ -n ${1:-} ]] || return
if [[ -e $(GetModulePath)/$(GetOriginalModuleSOFilename "_$1") ]];then
mv "$(GetModulePath)/$(GetOriginalModuleSOFilename "_$1")" "$(GetModulePath)/$(GetFixedModuleSOFilename "_$1")"
DisplayCommitToLog "= renamed module: _$1"
fi
if [[ -e $(GetModulePath)/$1/$(GetOriginalModuleSOFilename "$1") ]];then
mv "$(GetModulePath)/$1/$(GetOriginalModuleSOFilename "$1")" "$(GetModulePath)/$1/$(GetFixedModuleSOFilename "$1")"
DisplayCommitToLog "= renamed module: $1/$1"
fi
if [[ -e $(GetModulePath)/$(GetOriginalModuleSOFilename "$1") ]];then
mv "$(GetModulePath)/$(GetOriginalModuleSOFilename "$1")" "$(GetModulePath)/$(GetFixedModuleSOFilename "$1")"
DisplayCommitToLog "= renamed module: $1"
fi
return 0
}
GetOriginalModuleSOFilename()
{
[[ -z $pyver ]] && pyver=$(GetPythonVer)
[[ -n ${1:-} ]] && echo "$1.cpython-$pyver-$(/bin/uname -m)-linux-gnu.so"
}
GetFixedModuleSOFilename()
{
[[ -z $pyver ]] && pyver=$(GetPythonVer)
[[ -n ${1:-} ]] && echo "$1.cpython-$pyver.so"
}
GetModulePath()
{
[[ -z $pyver ]] && pyver=$(GetPythonVer)
echo "$venv_path/lib/python${pyver:0:1}.${pyver:1:2}/site-packages"
}
parse_yaml()
{
local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
/bin/sed -ne "s|^\($s\):|\1|" \
-e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
-e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
/bin/awk -F$fs '{
indent = length($1)/2;
vname[indent] = $2;
for (i in vname) {if (i > indent) {delete vname[i]}}
if (length($3) > 0) {
vn="";for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
printf("%s%s%s=\"%s\"\n", "'${2:-}'",vn, $2, $3);
}
}'
}
IsQNAP()
{
if [[ ! -e /etc/init.d/functions ]];then
Display 'QTS functions missing (is this a QNAP NAS?)'
SetError;return 1
fi
return 0
}
IsQPKGInstalled()
{
/bin/grep -q "^\[${1:-$r_qpkg_name}\]" /etc/config/qpkg.conf
}
IsNotQPKGInstalled()
{
! IsQPKGInstalled "${1:-$r_qpkg_name}"
}
IsQPKGActive()
{
IsDaemon && IsDaemonActive
}
IsNotQPKGActive()
{
! IsNotQPKGActive
}
IsQPKGEnabled()
{
[[ $(Lowercase "$(/sbin/getcfg ${1:-$r_qpkg_name} Enable -d false -f /etc/config/qpkg.conf)") = true ]]
}
IsNotQPKGEnabled()
{
! IsQPKGEnabled "${1:-$r_qpkg_name}"
}
IsSupportBackup()
{
[[ $qpkg_backup_pathfile != undefined ]]
}
IsNotSupportBackup()
{
! IsSupportBackup
}
IsSupportReset()
{
[[ $qpkg_ini_pathfile != undefined ]]
}
IsNotSupportReset()
{
! IsSupportReset
}
IsSupportActions()
{
[[ -e $r_service_action_pathfile || -e $r_service_result_pathfile ]]
}
IsNotSupportActions()
{
! IsSupportActions
}
IsSupportGetAppVersion()
{
[[ $get_app_version_cmd != undefined && $app_version_pathfile != undefined ]]
}
IsNotSupportGetAppVersion()
{
! IsSupportGetAppVersion
}
IsVirtualPythonEnv()
{
[[ $venv_path != undefined ]]
}
IsNotVirtualPythonEnv()
{
! IsVirtualPythonEnv
}
IsGitApp()
{
[[ $source_git_url != undefined && $source_git_branch != undefined && $qpkg_repo_path != undefined ]]
}
IsNotGitApp()
{
! IsGitApp
}
IsUsePipCache()
{
[[ $pip_cache_path != undefined ]]
}
IsNotUsePipCache()
{
! IsUsePipCache
}
IsOnlineReleasePackage()
{
[[ $remote_url != undefined ]]
}
IsNotOnlineReleasePackage()
{
! IsOnlineReleasePackage
}
IsReleaseAnArchive()
{
[[ $package_is_exec != undefined && $package_is_exec = false ]]
}
IsNotReleaseAnArchive()
{
! IsReleaseAnArchive
}
IsSupportAutoUpdate()
{
[[ $can_restart_to_update = true ]]
}
IsNotSupportAutoUpdate()
{
! IsSupportAutoUpdate
}
IsSourcedOnline()
{
IsGitApp || IsUsePipCache || IsOnlineReleasePackage
}
IsNotSourcedOnline()
{
! IsSourcedOnline
}
IsUseTemp()
{
[[ $r_qpkg_temp_path != undefined ]]
}
IsNotUseTemp()
{
! IsUseTemp
}
IsSSLEnabled()
{
eval "$get_ui_port_secure_enabled_test_cmd"
}
IsNotSSLEnabled()
{
! IsSSLEnabled
}
IsDaemon()
{
[[ $daemon_exec_pathfile != undefined ]]
}
IsNotDaemon()
{
! IsDaemon
}
IsDaemonCheck()
{
[[ $daemon_check_pathfile != undefined ]]
}
IsNotDaemonCheck()
{
! IsDaemonCheck
}
IsDaemonActive()
{
if IsDaemonProcessActive;then
DisplayCommitToLog "- daemon PID: '$(<"$daemon_pid_pathfile")'"
return 0
fi
DisplayCommitToLog '- daemon PID: none'
return 1
}
IsNotDaemonActive()
{
! IsDaemonActive
}
IsDaemonProcessActive()
{
if [[ -e $daemon_pid_pathfile && -d /proc/"$(<$daemon_pid_pathfile)" ]];then
if IsDaemonCheck;then
[[ $(/usr/bin/readlink /proc/"$(<$daemon_pid_pathfile)"/exe) = "$daemon_check_pathfile" ]]
else
[[ $(</proc/"$(<$daemon_pid_pathfile)"/cmdline) =~ $daemon_exec_pathfile ]]
fi
else
false
fi
}
IsSysFilePresent()
{
if [[ -z ${1:?pathfilename null} ]];then
SetError;return 1
fi
if [[ ! -e $1 ]];then
Display "A required NAS system file is missing: '$1'"
SetError;return 1
fi
return 0
}
IsNotSysFilePresent()
{
! IsSysFilePresent "${1:?pathfilename null}"
}
IsPortAvailable()
{
local port=${1//[!0-9]/}
[[ -n $port && $port -gt 0 ]] || return 0
/usr/sbin/lsof -i :"$port" -sTCP:LISTEN >/dev/null 2>&1 && return 1
return 0
}
IsNotPortAvailable()
{
! IsPortAvailable "${1:-0}"
}
IsPortResponds()
{
local -i a=${1//[!0-9]/}
local -i b=$(CalcAdaptiveSeconds "$port_check_timeout_seconds")
local -i c=0
if [[ -z $a ]];then
Display 'empty port: not testing for response'
return 1
elif [[ $a -eq 0 ]];then
Display "port '0': not testing for response"
return 1
fi
DisplayWaitCommitToLog "> test for port '$a' response (no-more than $b second$(Pluralise "$b")):"
while true;do
if ! IsDaemonProcessActive;then
DisplayCommitToLog 'process not active'
break
fi
/sbin/curl --silent --fail --max-time 1 http://localhost:"$a" &>/dev/null
case $? in
0|22|52)
Display OK
CommitToLog "responded in $c second$(Pluralise "$c")"
return 0
;;
28)
:
;;
7)
/bin/sleep 1
;;
*)
:
esac
((c++))
DisplayWait "$c,"
if [[ $c -ge $b ]];then
DisplayCommitToLog failed
CommitErrToSysLog "port '$a' failed to respond after $c second$(Pluralise "$c")!"
break
fi
done
return 1
}
IsPortSecureResponds()
{
local -i a=${1//[!0-9]/}
local -i b=$(CalcAdaptiveSeconds "$port_check_timeout_seconds")
local -i c=0
if [[ -z $a ]];then
Display 'empty port: not testing for response'
return 1
elif [[ $a -eq 0 ]];then
Display "port '0': not testing for response"
return 1
fi
DisplayWaitCommitToLog "> test for secure port '$a' response (no-more than $b second$(Pluralise "$b")):"
while true;do
if ! IsDaemonProcessActive;then
DisplayCommitToLog 'process not active'
break
fi
/sbin/curl --silent --insecure --fail --max-time 1 https://localhost:"$a" &>/dev/null
case $? in
0|22|52)
Display OK
CommitToLog "port responded after $c second$(Pluralise "$c")"
return 0
;;
35)
DisplayCommitToLog 'TLS inactive'
break
;;
28)
:
;;
7)
/bin/sleep 1
;;
*)
:
esac
((c++))
DisplayWait "$c,"
if [[ $c -ge $b ]];then
DisplayCommitToLog failed
CommitErrToSysLog "secure port '$a' failed to respond after $c second$(Pluralise "$c")!"
break
fi
done
return 1
}
IsConfigFound()
{
[[ $qpkg_ini_pathfile != undefined && -e $qpkg_ini_pathfile ]]
}
IsNotConfigFound()
{
! IsConfigFound
}
IsDefaultConfigFound()
{
[[ $qpkg_ini_default_pathfile != undefined && -e $qpkg_ini_default_pathfile ]]
}
IsNotDefaultConfigFound()
{
! IsDefaultConfigFound
}
IsVirtualPythonEnvExist()
{
[[ -e $venv_path/bin/activate ]]
}
IsNotVirtualPythonEnvExist()
{
! IsVirtualPythonEnvExist
}
OSIsSupportSecureDownload()
{
[[ ${r_nas_firmware_version//.} -ge 500 ]]
}
IsSiteUp()
{
[[ -n $1 && $1 != undefined ]] || return
local a=$(cut -d'/' -f3 <<< "$1" | cut -d':' -f1)
[[ -n $a && $a != undefined ]] || return
local -i n=0
for ((n=0;n<20; n++)); do
/bin/ping -c 1 -w 1 "$a" && return 0
/bin/sleep 5
done
return 1
} &>/dev/null
RequestLatestReleaseFilename()
{
[[ -n ${1:-} && ${1:-} != undefined ]] || return
local a="$curl_insecure_arg --silent --max-time $get_remote_filename_timeout_seconds --limit-rate 1K --location --dump-header -"
local b=$(/sbin/curl${a} "${1/https/http}" | /bin/grep -v 'Location:' | /bin/grep filename | cut -d';' -f2 | cut -d'=' -f2 | /bin/sed -e 's|\r||g')
[[ -n ${2:-} && ${2:-} != undefined ]] && b=$(/bin/grep "$2" <<< "$b")
printf '%s' "$b"
} 2>/dev/null
RequestLatestReleaseURL()
{
[[ -n ${1:-} && ${1:-} != undefined ]] || return
local a="$curl_insecure_arg --silent --max-time $get_remote_filename_timeout_seconds --location"
local b=$(/sbin/curl${a} "$1" | /bin/grep browser_download_url | cut -d\" -f4)
[[ -n ${2:-} && ${2:-} != undefined ]] && b=$(/bin/grep "$2" <<< "$b")
printf '%s' "$b"
} 2>/dev/null
DownloadReleasePackage()
{
[[ -n ${1:-} && ${1:-} != undefined ]] || return
[[ -n ${2:-} && ${2:-} != undefined ]] || return
local a=''
local b=$curl_insecure_arg
local c=$2
[[ $debug = false ]] && b+=' --silent'
if [[ -e $c ]];then
a='refresh existing release package (only-if-newer)'
b+=" --time-cond $c"
else
a='download latest release package'
fi
b+=" --show-error --max-time 300 --location --output $c"
DisplayRunAndLog "$a" "/sbin/curl${b} '$1'" log:failure-only
}
ExtractReleasePackage()
{
[[ -n ${1:-} && ${1:-} != undefined ]] || return
local release_package_name_ref_pathfilename=''
local release_package_pathfile=$1
local tar_opts=''
local tar_verbose=''
local unzip_opts=''
local unzip_verbose=''
[[ -n ${2:-} && ${2:-} != undefined ]] && release_package_name_ref_pathfilename=$2
if [[ $debug = true ]];then
tar_verbose=' --verbose'
fi
if [[ -e $release_package_pathfile ]];then
tar_opts="$tar_verbose --extract --gzip --file=$release_package_pathfile --directory=$qpkg_repo_path"
unzip_opts="$unzip_verbose -o $release_package_pathfile -d $qpkg_repo_path"
DisplayRunAndLog 'extract from release package' "/usr/bin/unzip${unzip_opts} 2>/dev/null || /bin/tar${tar_opts}" log:failure-only
if [[ $compare_release_filename = true && -n $release_package_name_ref_pathfilename ]];then
if [[ ! -e $release_package_name_ref_pathfilename ]];then
DisplayRunAndLog 'create release package name reference' "/bin/touch $release_package_name_ref_pathfilename" log:failure-only
fi
fi
fi
}
MakeExecReleasePackage()
{
[[ -n ${1:-} && ${1:-} != undefined ]] || return
local release_package_name_ref_pathfilename=''
local release_package_pathfile=$1
[[ -n ${2:-} && ${2:-} != undefined ]] && release_package_name_ref_pathfilename=$2
if [[ -e $release_package_pathfile ]];then
DisplayRunAndLog 'copy release package' "cp -f $release_package_pathfile $daemon_exec_pathfile" log:failure-only
[[ ! -x $daemon_exec_pathfile ]] && DisplayRunAndLog 'make release package executable' "chmod +x $daemon_exec_pathfile" log:failure-only
if [[ $compare_release_filename = true && -n $release_package_name_ref_pathfilename ]];then
if [[ ! -e $release_package_name_ref_pathfilename ]];then
DisplayRunAndLog 'create release package name reference' "/bin/touch $release_package_name_ref_pathfilename" log:failure-only
fi
fi
fi
}
ResetServiceAction()
{
SetServiceAction reset-action
SetServiceResultAsOK
}
SetServiceAction()
{
service_action=${1:-none}
CommitServiceAction
SetServiceResultAsInProgress
DisplayAndCommitActionToLog
}
SetServiceResultAsOK()
{
service_result=ok
CommitServiceResult
DisplayAndCommitResultToLog
}
SetServiceResultAsFailed()
{
service_result=failed
CommitServiceResult
DisplayAndCommitResultToLog
}
SetServiceResultAsAborted()
{
service_result=aborted
CommitServiceResult
DisplayAndCommitResultToLog
}
SetServiceResultAsInProgress()
{
service_result=in-progress
CommitServiceResult
}
SetServiceResultAsUnsupported()
{
service_result=unsupported
CommitServiceResult
}
CommitServiceAction()
{
if IsNotStatus && IsNotLog && IsNotNone;then
[[ $r_service_action_pathfile != undefined ]] && echo "$service_action" > "$r_service_action_pathfile"
fi
}
CommitServiceResult()
{
if IsNotStatus && IsNotLog && IsNotNone;then
[[ $r_service_result_pathfile != undefined ]] && echo "$service_result" > "$r_service_result_pathfile"
fi
}
SetQPKGWasActive()
{
_qpkg_was_active=true
}
UnsetQPKGWasActive()
{
_qpkg_was_active=false
}
QPKGWasActive()
{
[[ ${_qpkg_was_active:=false} = true ]]
}
QPKGWasNotActive()
{
[[ ${_qpkg_was_active:=false} = false ]]
}
SetStatusGet()
{
_get_status_flag=true
}
UnsetStatusGet()
{
_get_status_flag=false
}
IsStatus()
{
[[ ${_get_status_flag:=false} = true ]]
}
IsNotStatus()
{
! IsStatus
}
SetError()
{
IsError && return
_error_flag=true
}
UnsetError()
{
IsNotError && return
_error_flag=false
}
IsError()
{
[[ ${_error_flag:=false} = true ]]
}
IsNotError()
{
! IsError
}
IsReinstall()
{
[[ ${REINSTALL_QPKG:=false} = true ]]
}
IsUpgrade()
{
[[ ${UPGRADE_QPKG:=false} = true ]]
}
IsStart()
{
[[ $service_action = start ]]
}
IsNotStart()
{
! IsStart
}
IsStop()
{
[[ $service_action = stop ]]
}
IsNotStop()
{
! IsStop
}
IsRestart()
{
[[ $service_action = restart ]]
}
IsNotRestart()
{
! IsRestart
}
IsLog()
{
[[ $service_action = log ]]
}
IsNotLog()
{
! IsLog
}
IsNone()
{
[[ $service_action = none ]]
}
IsNotNone()
{
! IsNone
}
IsClean()
{
[[ $service_action = clean ]]
}
IsNotClean()
{
! IsClean
}
IsBackup()
{
[[ $service_action = backup ]]
}
IsNotBackup()
{
! IsBackup
}
IsRestore()
{
[[ $service_action = restore ]]
}
IsNotRestore()
{
! IsRestore
}
IsReset()
{
[[ $service_action = reset ]]
}
IsNotReset()
{
! IsReset
}
IsUnsupported()
{
[[ $service_action = unsupported ]]
}
IsServiceResultInProgress()
{
[[ $service_result = in-progress ]]
}
IsPathEmpty()
{
local a=${1:-}
[[ -n $a && -d $a ]] || return
rmdir "$a" &>/dev/null && mkdir "$a"
}
IsNotPathEmpty()
{
! IsPathEmpty "${1:-}"
}
ShowAsError()
{
Display "$(TextBrightRed derp): $(Capitalise "${1:-}")"
} >&2
DisplayCommitToLog()
{
Display "${1:-}"
CommitToLog "${1:-}"
}
DisplayWaitCommitToLog()
{
DisplayWait "${1:-}"
CommitToLogWait "${1:-}"
}
DisplayWarnCommitAllLogs()
{
DisplayCommitToLog "${1:-}"
CommitWarnToSysLog "${1:-}"
}
DisplayErrCommitAllLogs()
{
DisplayCommitToLog "${1:-}"
CommitErrToSysLog "${1:-}"
}
FormatAsLogFilename()
{
echo "= log file: '${1:-}'"
}
FormatAsCommand()
{
Display "command: '${1:-}'"
}
FormatAsStdout()
{
Display "output: \"${1:-}\""
}
FormatAsResult()
{
Display "result: $(FormatAsExitcode "${1:-}")"
}
FormatAsResultAndStdout()
{
if [[ ${1:-0} -eq 0 ]];then
echo "= result_code: $(FormatAsExitcode "$1")"
else
echo "= result_code: $(FormatAsExitcode "$1")"
fi
DebugBulletSeparatorWithText 'stdout & stderr begins below'
echo "${2:-}"
DebugBulletSeparatorWithText 'stdout & stderr is complete'
}
FormatAsFuncMessages()
{
echo "= ${FUNCNAME[1]}()"
FormatAsCommand "${1:?command null}"
FormatAsStdout "${2:-}"
}
FormatAsExitcode()
{
echo "[${1:-}]"
}
FormatAsPackageName()
{
echo "'${1:-}'"
}
DisplayAsHelp()
{
printf '  %-22s  - %s\n' "${1:-}" "${2:-}."
}
Display()
{
echo "${1:-}"
}
DisplayWait()
{
echo -n "${1:-} "
}
DisplayAndCommitActionToLog()
{
[[ $service_action = unspecified ]] && return
starttime=$(/bin/date +%s%N)
local msg="> source: $(/usr/bin/basename "$0"), action: $service_action, time: $(date), load: $(GetSysLoad1MinAverage)"
msg="$(/bin/tr -s ' ' <<< "$msg") "
local a=DisplayCommitToLog
if IsNotStatus && IsNotLog && IsNotNone;then
IsUnsupported && a=CommitToLog
CommitToLog '•'
$a "$(TextInverse "$msg")"
$a "- package: $r_qpkg_version, service: $r_service_script_version, library: $r_service_library_version"
fi
}
DisplayAndCommitResultToLog()
{
[[ $service_action = unspecified ]] && return
local msg="= source: $(/usr/bin/basename "$0"), action: $service_action, time: $(date), result: $service_result, elapsed: $(FormatAsDuration "$(CalcMilliDifference "$starttime" "$(/bin/date +%s%N)")"), load: $(GetSysLoad1MinAverage)"
msg="$(/bin/tr -s ' ' <<< "$msg") "
local a=DisplayCommitToLog
if IsNotStatus && IsNotLog && IsNotNone;then
IsUnsupported && a=CommitToLog
case $service_result in
ok)
$a "$(TextBlackOnGreen "$msg")"
;;
failed)
$a "$(TextBlackOnRed "$msg")"
;;
*)
$a "$(TextBlackOnYellow "$msg")"
esac
fi
}
CommitInfoToSysLog()
{
CommitSysLog "${1:-}" 4
}
CommitWarnToSysLog()
{
CommitSysLog "${1:-} Please check the service log for more information." 2
}
CommitErrToSysLog()
{
CommitSysLog "${1:-}" 1
}
CommitToLog()
{
if IsNotStatus && IsNotLog && IsNotNone;then
[[ ${1:-} = '•' && ! -s "$r_service_log_pathfile" ]] || echo -e "${1:-}" >> "$r_service_log_pathfile"
fi
}
CommitToLogWait()
{
if IsNotStatus && IsNotLog && IsNotNone;then
printf '%s' "${1:-} " >> "$r_service_log_pathfile"
fi
}
CommitSysLog()
{
if IsNotStatus && IsNotLog && IsNotNone;then
if [[ -z ${1:-} || -z ${2:-} ]];then
SetError;return 1
fi
/sbin/write_log "[$r_qpkg_name] $1" "$2"
fi
}
TextBrightWhite()
{
printf '\033[1;97m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBrightRed()
{
printf '\033[1;31m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBlackOnGreen()
{
printf '\033[30;42m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBlackOnRed()
{
printf '\033[30;41m%s\033[0m' "${1:-}"
} 2>/dev/null
TextBlackOnYellow()
{
printf '\033[30;43m%s\033[0m' "${1:-}"
} 2>/dev/null
TextInverse()
{
printf '\033[7m%s\033[0m' "${1:-}"
} 2>/dev/null
Pluralise()
{
[[ ${1:-0} -ne 1 ]] && echo s
}
CalcMilliDifference()
{
echo "$(((${2:-1}-${1:-0})/1000000))"
}
FormatAsThous()
{
local rightside_group=''
local foutput=''
local remainder=$(/bin/sed 's/[^0-9]*//g' <<< "${1:-}")
while [[ ${#remainder} -gt 0 ]];do
rightside_group=${remainder:${#remainder}<3?0:-3}
if [[ -z $foutput ]];then
foutput=$rightside_group
else
foutput=$rightside_group,$foutput
fi
if [[ ${#rightside_group} -eq 3 ]];then
remainder=${remainder%???}
else
break
fi
done
printf '%s' "$foutput"
return 0
}
FormatAsDuration()
{
if [[ ${1:-0} -lt 10000 ]];then
printf '%s' "$(FormatAsThous "${1:-0}")ms"
else
FormatSecsToHoursMinutesSecs "$(((${1:-0}+500)/1000))"
fi
}
FormatSecsToHoursMinutesSecs()
{
((h=${1:-0}/3600))
((m=(${1:-0}%3600)/60))
((s=${1:-0}%60))
printf '%01dh:%02dm:%02ds\n' "$h" "$m" "$s"
} 2>/dev/null
IsAutoUpdateMissing()
{
[[ $(/sbin/getcfg $r_qpkg_name Auto_Update -f /etc/config/qpkg.conf) = '' ]]
}
IsAutoUpdate()
{
IsSupportAutoUpdate && [[ $(Lowercase "$(/sbin/getcfg $r_qpkg_name Auto_Update -f /etc/config/qpkg.conf)") = true ]]
}
IsNotAutoUpdate()
{
! IsAutoUpdate
}
EnableAutoUpdate()
{
StoreAutoUpdateSelection true
}
DisableAutoUpdate()
{
StoreAutoUpdateSelection false
}
StoreAutoUpdateSelection()
{
/sbin/setcfg $r_qpkg_name Auto_Update "$(Uppercase "$1")" -f /etc/config/qpkg.conf
DisplayCommitToLog "- application auto-update: $1"
}
GetPathGitBranch()
{
[[ -n $1 ]] || return
/opt/bin/git -C "$1" branch | /bin/grep '^\*' | /bin/sed 's|^\* ||'
} 2>/dev/null
IsSU()
{
if [[ $EUID -ne 0 ]];then
if [[ -e /usr/bin/sudo ]];then
ShowAsError 'this utility must be run with superuser privileges. Try again as:'
Display "${r_chars_sudo_prompt}$0 $r_user_args_raw" >&2
else
ShowAsError "this utility must be run as the 'admin' user. Please login via SSH as 'admin' and try again"
fi
return 1
fi
return 0
}
ShowUnsupportedAction()
{
ShowAsError "specified action '$1' is unsupported by this service-script."
SetError
CommitToLog "- specified action '$1' is unsupported."
Display
ShowHelp
}
CalcAdaptiveSeconds()
{
local a=$(GetSysLoad1MinAverage);a=${a/./}
local b=$(($(GetCPUCores)*100))
local c=$((10#$a/10#$b))
local d=$((10#${1:-1}))
[[ $((10#$c)) -gt 1 ]] && d=$((c*d))
[[ $((10#$d)) -gt 1800 ]] && d=1800
printf '%s' "$d"
}
GetSysLoad1MinAverage()
{
/usr/bin/uptime | /bin/sed 's|.*load average: ||' | /bin/awk -F', ' '{print $1}'
}
GetCPUCores()
{
local a=$(/bin/grep -c '^processor' /proc/cpuinfo)
[[ $a -eq 0 ]] && a=$(/bin/grep -c '^Processor' /proc/cpuinfo)
printf '%s' "$a"
}
SetTraps()
{
trap CaughtSIGHUP SIGHUP
trap CaughtSIGINT SIGINT
trap CaughtEXIT EXIT
}
CaughtSIGHUP()
{
trap - SIGHUP
DisplayCommitToLog '* caught SIGHUP: abort.'
SetServiceResultAsAborted
exit
}
CaughtSIGINT()
{
trap - SIGINT
DisplayCommitToLog '* caught SIGINT: abort.'
SetServiceResultAsAborted
exit
}
CaughtEXIT()
{
trap - EXIT
if IsServiceResultInProgress;then
DisplayCommitToLog '* caught EXIT: abort.'
SetServiceResultAsAborted
fi
}
ProcessArgs()
{
if IsGitApp;then
local test_branch=$(/sbin/getcfg $r_qpkg_name Git_Branch -d unknown -f /etc/config/qpkg.conf)
if [[ $test_branch = unknown ]];then
/sbin/setcfg $r_qpkg_name Git_Branch $source_git_branch -f /etc/config/qpkg.conf
else
source_git_branch=$test_branch
fi
fi
if IsNotError;then
local user_arg=${r_user_args_raw%% *}
case $user_arg in
?(--)activate|?(--)start)
IsSU ||	exit
SetServiceAction start
if IsQPKGEnabled;then
SetTraps
StartQPKG
else
ShowDisabledPrompt
SetError
fi
;;
?(-)b|?(--)backup?(-config))
IsSU ||	exit
if IsSupportBackup;then
SetServiceAction backup
SetTraps
StopQPKG
BackupConfig
IsQPKGEnabled && StartQPKG
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(--)clean|?(--)update|?(--)upgrade)
IsSU ||	exit
if IsSourcedOnline;then
SetServiceAction clean
SetTraps
StopQPKG
[[ $r_qpkg_name = nzbToMedia ]] && BackupConfig
CleanLocalRepo
IsQPKGEnabled && StartQPKG
[[ $r_qpkg_name = nzbToMedia ]] && RestoreConfig
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(--)deactivate|?(--)stop)
IsSU ||	exit
SetServiceAction stop
SetTraps
StopQPKG
;;
?(--)disable)
IsSU ||	exit
SetServiceAction disable
SetTraps
/sbin/qpkg_service disable "$r_qpkg_name"
if IsNotQPKGEnabled;then
ShowDisabled
else
ShowDisableFailed
SetError
fi
;;
?(--)disable-auto-update)
IsSU ||	exit
if IsSupportAutoUpdate;then
SetServiceAction disable-auto-update
SetTraps
DisableAutoUpdate
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(--)enable)
IsSU ||	exit
SetServiceAction enable
SetTraps
/sbin/qpkg_service enable "$r_qpkg_name"
if IsQPKGEnabled;then
ShowEnabled
else
ShowEnableFailed
SetError
fi
;;
?(--)enable-auto-update)
IsSU ||	exit
if IsSupportAutoUpdate;then
SetServiceAction enable-auto-update
SetTraps
EnableAutoUpdate
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(--)help)
ShowHelp
;;
?(-)+(l|L)|?(--)log)
SetServiceAction log
ViewLog
;;
?(-)r|?(--)reactivate|?(--)restart)
IsSU ||	exit
SetServiceAction restart
if IsQPKGEnabled;then
SetTraps
StopQPKG && StartQPKG
else
ShowDisabledPrompt
SetError
fi
;;
remove)
SetServiceAction uninstall
;;
?(--)reset-action)
IsSU ||	exit
if IsSupportActions;then
ResetServiceAction
exit
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(--)reset-config)
IsSU ||	exit
if IsSupportReset;then
SetServiceAction reset
SetTraps
StopQPKG
ResetConfig
IsQPKGEnabled && StartQPKG
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(--)restore?(-config))
IsSU ||	exit
if IsSupportBackup;then
SetServiceAction restore
SetTraps
StopQPKG
RestoreConfig
IsQPKGEnabled && StartQPKG
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
;;
?(-)s|?(--)status)
SetStatusGet
StatusQPKG
;;
uninstall)
:
;;
?(-)+(v|V)|?(--)version?(s))
Display "package: '$r_qpkg_version'"
Display "service: '$r_service_script_version'"
Display "library: '$r_service_library_version'"
;;
*)
if [[ -z $user_arg ]];then
ShowHelp
else
SetServiceAction unsupported
ShowUnsupportedAction "$user_arg"
fi
esac
fi
if IsNotLog && IsNotNone;then
if IsError;then
SetServiceResultAsFailed
exit 1
else
SetServiceResultAsOK
fi
fi
exit 0
}
InitLibrary
